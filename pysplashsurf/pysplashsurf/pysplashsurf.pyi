# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

from __future__ import annotations

import builtins
import numpy
import numpy.typing
import os
import pathlib
import typing
from enum import Enum

class Aabb3d:
    r"""
    Three-dimensional axis-aligned bounding box defined by its minimum and maximum corners
    """
    @property
    def min(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        The min coordinate of the AABB
        """
    @property
    def max(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        The max coordinate of the AABB
        """
    @staticmethod
    def from_min_max(min:typing.Sequence[builtins.float], max:typing.Sequence[builtins.float]) -> Aabb3d:
        r"""
        Constructs an AABB with the given min and max coordinates
        """
    @staticmethod
    def from_points(points:numpy.typing.NDArray[typing.Any]) -> Aabb3d:
        r"""
        Constructs the smallest AABB fitting around all the given points
        """
    def contains_point(self, point:typing.Sequence[builtins.float]) -> builtins.bool:
        r"""
        Checks if the given point is inside the AABB, the AABB is considered to be half-open to its max coordinate
        """

class MeshAttribute:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the data stored in the attribute
        """
    @property
    def name(self) -> builtins.str:
        r"""
        Name of the attribute
        """
    @property
    def data(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        View of the attribute data as a numpy array
        """

class MeshWithData:
    r"""
    Mesh with attached point and cell attributes
    """
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either ``np.float32`` or ``np.float64``)
        """
    @property
    def nvertices(self) -> builtins.int:
        r"""
        Number of vertices in the mesh
        """
    @property
    def ncells(self) -> builtins.int:
        r"""
        Number of cells (triangles or quads) in the mesh
        """
    @property
    def mesh_type(self) -> MeshType:
        r"""
        Type of the underlying mesh
        """
    @property
    def mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        The wrapped mesh without associated data and attributes
        """
    @property
    def point_attributes(self) -> dict[str, numpy.typing.NDArray]:
        r"""
        The attributes attached points (vertices) of the mesh
        """
    @property
    def cell_attributes(self) -> dict[str, numpy.typing.NDArray]:
        r"""
        The attributes attached to the cells (triangles or quads) of the mesh
        """
    def __new__(cls, mesh:typing.Union[TriMesh3d, MeshWithData]) -> MeshWithData:
        r"""
        Wraps an existing mesh object (either `TriMesh3d` or `MixedTriQuadMesh3d`) such that data (point and cell attributes) can be attached to it
        """
    def copy_mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        Returns a copy of the wrapped mesh without associated data and attributes
        """
    def copy(self) -> MeshWithData:
        r"""
        Returns a copy (deep copy) of this mesh with its data and attributes
        """
    def add_point_attribute(self, name:builtins.str, attribute:numpy.typing.NDArray[typing.Any]) -> None:
        r"""
        Attaches a point attribute to the mesh
        
        There has to be exactly one attribute value per vertex in the mesh.
        As attribute data, the following numpy array types are supported:
         - 1D array with shape (N,) of ``np.uint64``
         - 1D array with shape (N,) of the mesh scalar type (``np.float32`` or ``np.float64``)
         - 2D array with shape (N,3) of the mesh scalar type (``np.float32`` or ``np.float64``)
        The data is copied into the mesh object.
        """
    def add_cell_attribute(self, name:builtins.str, attribute:numpy.typing.NDArray[typing.Any]) -> None:
        r"""
        Attaches a cell attribute to the mesh
        
        There has to be exactly one attribute value per cell in the mesh.
        As attribute data, the following numpy array types are supported:
         - 1D array with shape (N,) of ``np.uint64``
         - 1D array with shape (N,) of the mesh scalar type (``np.float32`` or ``np.float64``)
         - 2D array with shape (N,3) of the mesh scalar type (``np.float32`` or ``np.float64``)
        The data is copied into the mesh object.
        """
    def write_to_file(self, path:builtins.str | os.PathLike | pathlib.Path, *, file_format:typing.Optional[builtins.str]='vtk42') -> None:
        r"""
        Writes the mesh and its attributes to a file using ``meshio.write_points_cells``
        """

class MixedTriQuadMesh3d:
    r"""
    Mixed triangle and quad surface mesh in 3D
    """
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either ``np.float32`` or ``np.float64``)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    def copy(self) -> MixedTriQuadMesh3d:
        r"""
        Returns a copy (deep copy) of this mesh
        """
    def get_triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all triangle cells of the mesh as an `Nx3` array of vertex indices
        """
    def get_quads(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all quad cells of the mesh as an `Nx4` array of vertex indices
        """
    def write_to_file(self, path:builtins.str | os.PathLike | pathlib.Path, *, file_format:typing.Optional[builtins.str]='vtk42') -> None:
        r"""
        Writes the mesh to a file using ``meshio.write_points_cells``
        """

class NeighborhoodLists:
    r"""
    Per particle neighborhood lists
    """
    def __len__(self) -> builtins.int:
        r"""
        Returns the number of particles for which neighborhood lists are stored
        """
    def __getitem__(self, idx:builtins.int) -> builtins.list[builtins.int]:
        r"""
        Returns the neighborhood list for the particle at the given index
        """
    def get_neighborhood_lists(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns all stored neighborhood lists as a list of lists
        """

class SphInterpolator:
    r"""
    Interpolator of per-particle quantities to arbitrary points using SPH interpolation (with cubic kernel)
    """
    def __new__(cls, particle_positions:numpy.typing.NDArray[typing.Any], particle_densities:numpy.typing.NDArray[typing.Any], particle_rest_mass:builtins.float, compact_support_radius:builtins.float) -> SphInterpolator:
        r"""
        Constructs an SPH interpolator (with cubic kernels) for the given particles
        """
    def interpolate_quantity(self, particle_quantity:numpy.typing.NDArray[typing.Any], interpolation_points:numpy.typing.NDArray[typing.Any], *, first_order_correction:builtins.bool=False) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Interpolates a scalar or vectorial per particle quantity to the given points
        """
    def interpolate_normals(self, interpolation_points:numpy.typing.NDArray[typing.Any]) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Interpolates surface normals (i.e. normalized SPH gradient of the indicator function) of the fluid to the given points using SPH interpolation
        """

class SurfaceReconstruction:
    r"""
    Result returned by surface reconstruction functions with surface mesh and other data
    """
    @property
    def grid(self) -> UniformGrid:
        r"""
        The marching cubes grid parameters used for the surface reconstruction
        """
    @property
    def particle_densities(self) -> typing.Optional[numpy.typing.NDArray[typing.Any]]:
        r"""
        The global array of particle densities (`None` if they were only computed locally)
        """
    @property
    def particle_inside_aabb(self) -> typing.Optional[numpy.typing.NDArray[typing.Any]]:
        r"""
        A boolean array indicating whether each particle was inside the AABB used for the reconstruction (`None` if no AABB was set)
        """
    @property
    def particle_neighbors(self) -> typing.Optional[NeighborhoodLists]:
        r"""
        The global neighborhood lists per particle (`None` if they were only computed locally)
        """
    @property
    def mesh(self) -> TriMesh3d:
        r"""
        The reconstructed triangle mesh
        """

class TriMesh3d:
    r"""
    Triangle surface mesh in 3D
    """
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either ``np.float32`` or ``np.float64``)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    @property
    def triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        The `Mx3` array of vertex indices per triangle
        """
    def copy(self) -> TriMesh3d:
        r"""
        Returns a copy (deep copy) of this mesh
        """
    def vertex_normals_parallel(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Computes the vertex normals of the mesh using an area weighted average of the adjacent triangle faces
        """
    def vertex_vertex_connectivity(self) -> VertexVertexConnectivity:
        r"""
        Computes the vertex-vertex connectivity of the mesh
        """
    def write_to_file(self, path:builtins.str | os.PathLike | pathlib.Path, *, file_format:typing.Optional[builtins.str]='vtk42') -> None:
        r"""
        Writes the mesh to a file using ``meshio.write_points_cells``
        """

class UniformGrid:
    r"""
    Struct containing the parameters of the uniform grid used for the surface reconstruction
    """
    @property
    def aabb(self) -> Aabb3d:
        r"""
        The AABB of the grid containing all marching cubes vertices influenced by the particle kernels
        """
    @property
    def cell_size(self) -> builtins.float:
        r"""
        Returns the cell size of the uniform grid (the marching cubes voxel size)
        """
    @property
    def npoints_per_dim(self) -> builtins.list[builtins.int]:
        r"""
        Returns the number of points (marching cubes vertices) per dimension in the uniform grid
        """
    @property
    def ncells_per_dim(self) -> builtins.list[builtins.int]:
        r"""
        Returns the number of cells (marching cubes voxels) per dimension in the uniform grid
        """

class VertexVertexConnectivity:
    r"""
    Vertex-vertex connectivity of a mesh
    """
    def copy_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a copy of the wrapped connectivity data
        """
    def take_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns the wrapped connectivity data by moving it out of this object (zero copy)
        """

class MeshType(Enum):
    r"""
    Enum specifying the type of mesh wrapped by a ``MeshWithData``
    """
    Tri3d = ...
    r"""
    3D triangle mesh
    """
    MixedTriQuad3d = ...
    r"""
    3D mixed triangle and quad mesh
    """

def barnacle_decimation(mesh:typing.Union[TriMesh3d, MeshWithData], *, keep_vertices:builtins.bool) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs specialized decimation on the given mesh to prevent "barnacles" when applying weighted Laplacian smoothing
    
    The decimation is performed inplace and modifies the given mesh.
    Returns the vertex-vertex connectivity of the decimated mesh which can be used for other
    post-processing steps.
    """

def check_mesh_consistency(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, check_closed:builtins.bool=True, check_manifold:builtins.bool=True, debug:builtins.bool=False) -> typing.Optional[builtins.str]:
    r"""
    Checks the consistency of a reconstructed surface mesh (watertightness, manifoldness), optionally returns a string with details if problems are found
    """

def convert_tris_to_quads(mesh:typing.Union[TriMesh3d, MeshWithData], *, non_squareness_limit:builtins.float=1.75, normal_angle_limit:builtins.float=10.0, max_interior_angle:builtins.float=135.0) -> typing.Union[MixedTriQuadMesh3d, MeshWithData]:
    r"""
    Converts triangles to quads by merging triangles sharing an edge if they fulfill the given criteria
    
    This operation creates a new mesh and does not modify the input mesh.
    Angles are specified in degrees.
    """

def laplacian_smoothing_normals_parallel(normals:numpy.typing.NDArray[typing.Any], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int) -> None:
    r"""
    Laplacian smoothing of a normal field
    
    The smoothing is performed inplace and modifies the given normal array.
    """

def laplacian_smoothing_parallel(mesh:typing.Union[TriMesh3d, MeshWithData], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int, beta:builtins.float=1.0, weights:numpy.typing.NDArray[typing.Any]) -> None:
    r"""
    Laplacian smoothing of mesh vertices with feature weights
    
    The smoothing is performed inplace and modifies the vertices of the given mesh.
    """

def marching_cubes(values:numpy.typing.NDArray[typing.Any], *, iso_surface_threshold:builtins.float, cube_size:builtins.float, translation:typing.Optional[typing.Sequence[builtins.float]]=None, return_grid:builtins.bool=False) -> typing.Union[TriMesh3d, tuple[TriMesh3d, UniformGrid]]:
    r"""
    Performs a standard marching cubes triangulation of a 3D array of values
    
    The array of values has to be a contiguous array with shape ``(nx, ny, nz)``.
    The iso-surface threshold defines which value is considered to be "on" the surface.
    The cube size and translation parameters define the scaling and translation of the resulting
    mesh. Without translation, the value ``values[0, 0, 0]`` is located at coordinates ``(0, 0, 0)``.
    
    The values are interpreted as a "density field", meaning that values higher than the iso-surface
    threshold are considered to be "inside" the surface and values lower than the threshold are
    considered to be "outside" the surface. This is the opposite convention to an SDF (signed distance field).
    However, even if values of an SDF are provided as an input, the marching cubes algorithm
    will still work and produce a watertight surface mesh (if the surface is fully contained in the
    array).
    
    If ``return_grid`` is set to ``True``, the function will return a tuple of the mesh and the
    uniform grid that was used for the triangulation. This can be used for other functions such as
    :py:func:`check_mesh_consistency`. Otherwise, only the mesh is returned.
    
    The function is currently single-threaded. The SPH surface reconstruction functions :py:func:`reconstruction_pipeline`
    and :py:func:`reconstruct_surface` improve performance by processing multiple patches in parallel.
    """

def marching_cubes_cleanup(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, max_rel_snap_dist:typing.Optional[builtins.float]=None, max_iter:builtins.int=5, keep_vertices:builtins.bool=False) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs simplification on the given mesh inspired by the "Compact Contouring"/"Mesh displacement" approach by Doug Moore and Joe Warren
    
    The simplification is performed inplace and modifies the given mesh.
    The method is designed specifically for meshes generated by Marching Cubes.
    See Moore and Warren: `Mesh Displacement: An Improved Contouring Method for Trivariate Data <https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.5214&rep=rep1&type=pdf>`_ (1991)
    or Moore and Warren: "Compact Isocontours from Sampled Data" in "Graphics Gems III" (1992).
    """

def neighborhood_search_spatial_hashing_parallel(particle_positions:numpy.typing.NDArray[typing.Any], domain:Aabb3d, search_radius:builtins.float) -> NeighborhoodLists:
    r"""
    Performs a neighborhood search using spatial hashing (multithreaded implementation)
    """

def reconstruct_surface(particles:numpy.typing.NDArray[typing.Any], *, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, multi_threading:builtins.bool=True, global_neighborhood_list:builtins.bool=False, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None) -> SurfaceReconstruction:
    r"""
    Performs a surface reconstruction from the given particles without additional post-processing
    
    Note that all parameters use absolute distance units and are not relative to the particle radius.
    """

def reconstruction_pipeline(particles:numpy.typing.NDArray[typing.Any], *, attributes_to_interpolate:typing.Optional[dict]=None, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, multi_threading:builtins.bool=True, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64, check_mesh_closed:builtins.bool=False, check_mesh_manifold:builtins.bool=False, check_mesh_orientation:builtins.bool=False, check_mesh_debug:builtins.bool=False, mesh_cleanup:builtins.bool=False, mesh_cleanup_snap_dist:typing.Optional[builtins.float]=None, decimate_barnacles:builtins.bool=False, keep_vertices:builtins.bool=False, compute_normals:builtins.bool=False, sph_normals:builtins.bool=False, normals_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_weights:builtins.bool=True, mesh_smoothing_weights_normalization:builtins.float=13.0, generate_quads:builtins.bool=False, quad_max_edge_diag_ratio:builtins.float=1.75, quad_max_normal_angle:builtins.float=10.0, quad_max_interior_angle:builtins.float=135.0, output_mesh_smoothing_weights:builtins.bool=False, output_raw_normals:builtins.bool=False, output_raw_mesh:builtins.bool=False, mesh_aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_clamp_vertices:builtins.bool=True, dtype:typing.Optional[numpy.dtype]=None) -> tuple[MeshWithData, SurfaceReconstruction]:
    r"""
    Runs the surface reconstruction pipeline for the given particle positions with optional post-processing
    
    Note that smoothing length and cube size are given in multiples of the particle radius.
    """
