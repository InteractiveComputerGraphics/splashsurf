# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

from __future__ import annotations

import builtins
import numpy
import numpy.typing
import os
import pathlib
import typing
from enum import Enum

class Aabb3d:
    r"""
    Three-dimensional axis-aligned bounding box defined by its minimum and maximum corners
    """
    @property
    def min(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        The min coordinate of the AABB
        """
    @property
    def max(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        The max coordinate of the AABB
        """
    @staticmethod
    def from_min_max(min:typing.Sequence[builtins.float], max:typing.Sequence[builtins.float]) -> Aabb3d:
        r"""
        Constructs an AABB with the given min and max coordinates
        """
    @staticmethod
    def from_points(points:numpy.typing.NDArray[typing.Any]) -> Aabb3d:
        r"""
        Constructs the smallest AABB fitting around all the given points
        """
    def contains_point(self, point:typing.Sequence[builtins.float]) -> builtins.bool:
        r"""
        Checks if the given point is inside the AABB, the AABB is considered to be half-open to its max coordinate
        """

class MeshAttribute:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the data stored in the attribute
        """
    @property
    def name(self) -> builtins.str:
        r"""
        Name of the attribute
        """
    @property
    def data(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        View of the attribute data as a numpy array
        """

class MeshWithData:
    r"""
    Mesh with attached point and cell attributes
    """
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either ``np.float32`` or ``np.float64``)
        """
    @property
    def nvertices(self) -> builtins.int:
        r"""
        Number of vertices in the mesh
        """
    @property
    def ncells(self) -> builtins.int:
        r"""
        Number of cells (triangles or quads) in the mesh
        """
    @property
    def mesh_type(self) -> MeshType:
        r"""
        Type of the underlying mesh
        """
    @property
    def mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        The wrapped mesh without associated data and attributes
        """
    @property
    def point_attributes(self) -> dict[str, numpy.typing.NDArray]:
        r"""
        The attributes attached points (vertices) of the mesh
        """
    @property
    def cell_attributes(self) -> dict[str, numpy.typing.NDArray]:
        r"""
        The attributes attached to the cells (triangles or quads) of the mesh
        """
    def __new__(cls, mesh:typing.Union[TriMesh3d, MeshWithData]) -> MeshWithData:
        r"""
        Wraps an existing mesh object (either `TriMesh3d` or `MixedTriQuadMesh3d`) such that data (point and cell attributes) can be attached to it
        """
    def copy_mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        Returns a copy of the wrapped mesh without associated data and attributes
        """
    def copy(self) -> MeshWithData:
        r"""
        Returns a copy (deep copy) of this mesh with its data and attributes
        """
    def add_point_attribute(self, name:builtins.str, attribute:numpy.typing.NDArray[typing.Any]) -> None:
        r"""
        Attaches a point attribute to the mesh
        
        There has to be exactly one attribute value per vertex in the mesh.
        As attribute data, the following numpy array types are supported:
         - 1D array with shape (N,) of ``np.uint64``
         - 1D array with shape (N,) of the mesh scalar type (``np.float32`` or ``np.float64``)
         - 2D array with shape (N,3) of the mesh scalar type (``np.float32`` or ``np.float64``)
        The data is copied into the mesh object.
        """
    def add_cell_attribute(self, name:builtins.str, attribute:numpy.typing.NDArray[typing.Any]) -> None:
        r"""
        Attaches a cell attribute to the mesh
        
        There has to be exactly one attribute value per cell in the mesh.
        As attribute data, the following numpy array types are supported:
         - 1D array with shape (N,) of ``np.uint64``
         - 1D array with shape (N,) of the mesh scalar type (``np.float32`` or ``np.float64``)
         - 2D array with shape (N,3) of the mesh scalar type (``np.float32`` or ``np.float64``)
        The data is copied into the mesh object.
        """
    def write_to_file(self, path:builtins.str | os.PathLike | pathlib.Path, *, file_format:typing.Optional[builtins.str]='vtk42') -> None:
        r"""
        Writes the mesh and its attributes to a file using ``meshio.write_points_cells``
        """

class MixedTriQuadMesh3d:
    r"""
    Mixed triangle and quad surface mesh in 3D
    """
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either ``np.float32`` or ``np.float64``)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    def copy(self) -> MixedTriQuadMesh3d:
        r"""
        Returns a copy (deep copy) of this mesh
        """
    def get_triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all triangle cells of the mesh as an `Nx3` array of vertex indices
        """
    def get_quads(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all quad cells of the mesh as an `Nx4` array of vertex indices
        """
    def write_to_file(self, path:builtins.str | os.PathLike | pathlib.Path, *, file_format:typing.Optional[builtins.str]='vtk42') -> None:
        r"""
        Writes the mesh to a file using ``meshio.write_points_cells``
        """

class NeighborhoodLists:
    r"""
    Per particle neighborhood lists
    """
    def __len__(self) -> builtins.int:
        r"""
        Returns the number of particles for which neighborhood lists are stored
        """
    def __getitem__(self, idx:builtins.int) -> builtins.list[builtins.int]:
        r"""
        Returns the neighborhood list for the particle at the given index
        """
    def get_neighborhood_lists(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns all stored neighborhood lists as a list of lists
        """

class SphInterpolator:
    r"""
    Interpolator of per-particle quantities to arbitrary points using SPH interpolation (with cubic kernel)
    """
    def __new__(cls, particle_positions:numpy.typing.NDArray[typing.Any], particle_densities:numpy.typing.NDArray[typing.Any], particle_rest_mass:builtins.float, compact_support_radius:builtins.float) -> SphInterpolator:
        r"""
        Constructs an SPH interpolator (with cubic kernels) for the given particles
        
        Parameters
        ----------
        particle_positions : numpy.ndarray
            A two-dimensional numpy array of shape (N, 3) containing the positions of the particles that are used for interpolation.
        particle_densities : numpy.ndarray
            A one-dimensional numpy array of shape (N,) containing the densities of the particles.
        particle_rest_mass
            The rest mass of each particle (assumed to be the same for all particles).
        compact_support_radius
            The compact support radius of the cubic spline kernel used for interpolation.
        """
    def interpolate_quantity(self, particle_quantity:numpy.typing.NDArray[typing.Any], interpolation_points:numpy.typing.NDArray[typing.Any], *, first_order_correction:builtins.bool=False) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Interpolates a scalar or vectorial per particle quantity to the given points
        """
    def interpolate_normals(self, interpolation_points:numpy.typing.NDArray[typing.Any]) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Interpolates surface normals (i.e. normalized SPH gradient of the indicator function) of the fluid to the given points using SPH interpolation
        """

class SurfaceReconstruction:
    r"""
    Result returned by surface reconstruction functions with surface mesh and other data
    """
    @property
    def grid(self) -> UniformGrid:
        r"""
        The marching cubes grid parameters used for the surface reconstruction
        """
    @property
    def particle_densities(self) -> typing.Optional[numpy.typing.NDArray[typing.Any]]:
        r"""
        The global array of particle densities (`None` if they were only computed locally)
        """
    @property
    def particle_inside_aabb(self) -> typing.Optional[numpy.typing.NDArray[typing.Any]]:
        r"""
        A boolean array indicating whether each particle was inside the AABB used for the reconstruction (`None` if no AABB was set)
        """
    @property
    def particle_neighbors(self) -> typing.Optional[NeighborhoodLists]:
        r"""
        The global neighborhood lists per particle (`None` if they were only computed locally)
        """
    @property
    def mesh(self) -> TriMesh3d:
        r"""
        The reconstructed triangle mesh
        """

class TriMesh3d:
    r"""
    Triangle surface mesh in 3D
    """
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either ``np.float32`` or ``np.float64``)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    @property
    def triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        The `Mx3` array of vertex indices per triangle
        """
    def copy(self) -> TriMesh3d:
        r"""
        Returns a copy (deep copy) of this mesh
        """
    def vertex_normals_parallel(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Computes the vertex normals of the mesh using an area weighted average of the adjacent triangle faces
        """
    def vertex_vertex_connectivity(self) -> VertexVertexConnectivity:
        r"""
        Computes the vertex-vertex connectivity of the mesh
        """
    def write_to_file(self, path:builtins.str | os.PathLike | pathlib.Path, *, file_format:typing.Optional[builtins.str]='vtk42') -> None:
        r"""
        Writes the mesh to a file using ``meshio.write_points_cells``
        """

class UniformGrid:
    r"""
    Struct containing the parameters of the uniform grid used for the surface reconstruction
    """
    @property
    def aabb(self) -> Aabb3d:
        r"""
        The AABB of the grid containing all marching cubes vertices influenced by the particle kernels
        """
    @property
    def cell_size(self) -> builtins.float:
        r"""
        Returns the cell size of the uniform grid (the marching cubes voxel size)
        """
    @property
    def npoints_per_dim(self) -> builtins.list[builtins.int]:
        r"""
        Returns the number of points (marching cubes vertices) per dimension in the uniform grid
        """
    @property
    def ncells_per_dim(self) -> builtins.list[builtins.int]:
        r"""
        Returns the number of cells (marching cubes voxels) per dimension in the uniform grid
        """

class VertexVertexConnectivity:
    r"""
    Vertex-vertex connectivity of a mesh
    """
    def copy_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a copy of the wrapped connectivity data
        """
    def take_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns the wrapped connectivity data by moving it out of this object (zero copy)
        """

class MeshType(Enum):
    r"""
    Enum specifying the type of mesh wrapped by a ``MeshWithData``
    """
    Tri3d = ...
    r"""
    3D triangle mesh
    """
    MixedTriQuad3d = ...
    r"""
    3D mixed triangle and quad mesh
    """

def barnacle_decimation(mesh:typing.Union[TriMesh3d, MeshWithData], *, keep_vertices:builtins.bool) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs specialized decimation on the given mesh to prevent "barnacles" when applying weighted Laplacian smoothing
    
    The decimation is performed inplace and modifies the given mesh.
    Returns the vertex-vertex connectivity of the decimated mesh which can be used for other
    post-processing steps.
    
    Parameters
    ----------
    mesh
        The triangle mesh to decimate.
    keep_vertices
        Flag to retain any vertices without connectivity resulting from decimation instead of filtering them out.
    """

def check_mesh_consistency(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, check_closed:builtins.bool=True, check_manifold:builtins.bool=True, debug:builtins.bool=False) -> typing.Optional[builtins.str]:
    r"""
    Checks the consistency of a reconstructed surface mesh (watertightness, manifoldness), optionally returns a string with details, if problems are found
    
    Parameters
    ----------
    mesh
        The triangle mesh to check for consistency.
    grid
        The uniform grid that was used for the marching cubes triangulation of the input mesh.
    check_closed
        Flag to enable checking if the mesh is closed (watertight).
    check_manifold
        Flag to enable checking if the mesh is manifold (i.e. has no non-manifold vertices & edges).
    debug
        Flag to enable additional debug output during the consistency checks.
    
    Returns
    -------
        An optional string with details about the problems found during the consistency checks.
        If no problems are found, None is returned.
    """

def convert_tris_to_quads(mesh:typing.Union[TriMesh3d, MeshWithData], *, non_squareness_limit:builtins.float=1.75, normal_angle_limit:builtins.float=10.0, max_interior_angle:builtins.float=135.0) -> typing.Union[MixedTriQuadMesh3d, MeshWithData]:
    r"""
    Converts triangles to quads by merging triangles sharing an edge if they fulfill the given criteria
    
    This operation creates a new mesh and does not modify the input mesh.
    Angles are specified in degrees.
    
    Parameters
    ----------
    mesh
        The triangle mesh to convert to a mixed triangle-quad mesh.
    non_squareness_limit
        Maximum allowed ratio of quad edge lengths to its diagonals to merge two triangles to a quad (inverse is used for minimum).
    normal_angle_limit
        Maximum allowed angle (in degrees) between triangle normals to merge them to a quad.
    max_interior_angle
        Maximum allowed vertex interior angle (in degrees) inside a quad to merge two triangles to a quad.
    """

def laplacian_smoothing_normals_parallel(normals:numpy.typing.NDArray[typing.Any], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int) -> None:
    r"""
    Laplacian smoothing of a normal field
    
    The smoothing is performed inplace and modifies the given normal array.
    
    Parameters
    ----------
    normals
        A two-dimensional array of shape (N, 3) containing the normals to smooth.
    vertex_connectivity
        The vertex-vertex connectivity of the mesh, required for efficient smoothing.
    iterations
        The number of smoothing iterations to perform.
    """

def laplacian_smoothing_parallel(mesh:typing.Union[TriMesh3d, MeshWithData], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int, beta:builtins.float=1.0, weights:numpy.typing.NDArray[typing.Any]) -> None:
    r"""
    Laplacian smoothing of mesh vertices with feature weights
    
    The smoothing is performed inplace and modifies the vertices of the given mesh.
    
    Parameters
    ----------
    mesh
        The triangle mesh to smooth.
    vertex_connectivity
        The vertex-vertex connectivity of the mesh, required for efficient smoothing.
    iterations
        The number of smoothing iterations to perform.
    beta
        Factor used for blending the original vertex position with the smoothed position.
    weights
        A one-dimensional array of weights per vertex that influence the smoothing.
        The weight is multiplied with beta.
    """

def marching_cubes(values:numpy.typing.NDArray[typing.Any], *, iso_surface_threshold:builtins.float, cube_size:builtins.float, translation:typing.Optional[typing.Sequence[builtins.float]]=None, return_grid:builtins.bool=False) -> typing.Union[TriMesh3d, tuple[TriMesh3d, UniformGrid]]:
    r"""
    Performs a standard marching cubes triangulation of a 3D array of values
    
    The array of values has to be a contiguous array with shape ``(nx, ny, nz)``.
    The iso-surface threshold defines which value is considered to be "on" the surface.
    The cube size and translation parameters define the scaling and translation of the resulting
    mesh. Without translation, the value ``values[0, 0, 0]`` is located at coordinates ``(0, 0, 0)``.
    
    The values are interpreted as a "density field", meaning that values higher than the iso-surface
    threshold are considered to be "inside" the surface and values lower than the threshold are
    considered to be "outside" the surface. This is the opposite convention to an SDF (signed distance field).
    However, even if values of an SDF are provided as an input, the marching cubes algorithm
    will still work and produce a watertight surface mesh (if the surface is fully contained in the
    array).
    
    If ``return_grid`` is set to ``True``, the function will return a tuple of the mesh and the
    uniform grid that was used for the triangulation. This can be used for other functions such as
    :py:func:`check_mesh_consistency`. Otherwise, only the mesh is returned.
    
    The function is currently single-threaded. The SPH surface reconstruction functions :py:func:`reconstruction_pipeline`
    and :py:func:`reconstruct_surface` improve performance by processing multiple patches in parallel.
    
    Parameters
    ----------
    values : numpy.ndarray
       A three-dimensional numpy array of shape (nx, ny, nz) containing the scalar values at the vertices
       of the marching cubes grid.
    iso_surface_threshold
       The iso-surface threshold value used to determine the surface.
    cube_size
       The size of each cube/voxel of the marching cubes grid. Determines the scaling of the resulting mesh.
    translation
       An optional translation vector [tx, ty, tz] applied to the entire mesh after scaling.
    """

def marching_cubes_cleanup(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, max_rel_snap_dist:typing.Optional[builtins.float]=None, max_iter:builtins.int=5, keep_vertices:builtins.bool=False) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs simplification on the given mesh inspired by the "Compact Contouring"/"Mesh displacement" approach by Doug Moore and Joe Warren
    
    The simplification is performed inplace and modifies the given mesh.
    The method is designed specifically for meshes generated by Marching Cubes.
    See Moore and Warren: `Mesh Displacement: An Improved Contouring Method for Trivariate Data <https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.5214&rep=rep1&type=pdf>`_ (1991)
    or Moore and Warren: "Compact Isocontours from Sampled Data" in "Graphics Gems III" (1992).
    
    Parameters
    ----------
    mesh
        The triangle mesh to simplify.
    grid
        The uniform grid that was used for the marching cubes triangulation of the input mesh.
    max_rel_snap_dist
        Optional maximum relative snapping distance (relative to the grid cell size) to merge close vertices.
    max_iter
        The maximum number of iterations of cleanup to perform.
    keep_vertices
        Flag to retain any vertices without connectivity resulting from simplification instead of filtering them out.
    """

def neighborhood_search_spatial_hashing_parallel(particle_positions:numpy.typing.NDArray[typing.Any], domain:Aabb3d, search_radius:builtins.float) -> NeighborhoodLists:
    r"""
    Performs a neighborhood search using spatial hashing (multithreaded implementation)
    
    Parameters
    ----------
    particles : numpy.ndarray
        A two-dimensional numpy array of shape (N, 3) containing the positions of the particles.
    domain
        An axis-aligned bounding box (AABB) of the particles used for spatial hashing.
        The neighborhood search fails if particles are outside the domain.
    search_radius
        The radius per particle where other particles are considered neighbors.
    """

def reconstruct_surface(particles:numpy.typing.NDArray[typing.Any], *, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, multi_threading:builtins.bool=True, global_neighborhood_list:builtins.bool=False, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64) -> SurfaceReconstruction:
    r"""
    Performs a surface reconstruction from the given particles without additional post-processing
    
    Note that all parameters use absolute distance units and are not relative to the particle radius.
    
    Parameters
    ----------
    particles : numpy.ndarray
        A two-dimensional numpy array of shape (N, 3) containing the positions of the particles.
    particle_radius
        Particle radius.
    rest_density
        Rest density of the fluid.
    smoothing_length
        Smoothing length of the SPH kernel in absolute distance units (compact support radius of SPH kernel will be twice the smoothing length).
    cube_size
        Size of the cubes (voxels) used for the marching cubes grid in absolute distance units.
    iso_surface_threshold
        Threshold of the SPH interpolation of the "color field" where the iso surface should be extracted.
    aabb_min
        Lower corner of the AABB of particles to consider in the reconstruction.
    aabb_max
        Upper corner of the AABB of particles to consider in the reconstruction.
    multi_threading
        Flag to enable multi-threading for the reconstruction and post-processing steps.
    subdomain_grid
        Flag to enable spatial decomposition by dividing the domain into subdomains with dense marching cube grids for efficient multi-threading.
    subdomain_grid_auto_disable
        Flag to automatically disable the subdomain grid if the global domain is too small.
    subdomain_num_cubes_per_dim
        Number of marching cubes voxels along each coordinate axis in each subdomain if the subdomain grid is enabled.
    """

def reconstruction_pipeline(particles:numpy.typing.NDArray[typing.Any], *, attributes_to_interpolate:typing.Optional[dict]=None, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, multi_threading:builtins.bool=True, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64, check_mesh_closed:builtins.bool=False, check_mesh_manifold:builtins.bool=False, check_mesh_orientation:builtins.bool=False, check_mesh_debug:builtins.bool=False, mesh_cleanup:builtins.bool=False, mesh_cleanup_snap_dist:typing.Optional[builtins.float]=None, decimate_barnacles:builtins.bool=False, keep_vertices:builtins.bool=False, compute_normals:builtins.bool=False, sph_normals:builtins.bool=False, normals_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_weights:builtins.bool=True, mesh_smoothing_weights_normalization:builtins.float=13.0, generate_quads:builtins.bool=False, quad_max_edge_diag_ratio:builtins.float=1.75, quad_max_normal_angle:builtins.float=10.0, quad_max_interior_angle:builtins.float=135.0, output_mesh_smoothing_weights:builtins.bool=False, output_raw_normals:builtins.bool=False, output_raw_mesh:builtins.bool=False, mesh_aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_clamp_vertices:builtins.bool=True) -> tuple[MeshWithData, SurfaceReconstruction]:
    r"""
    Runs the surface reconstruction pipeline for the given particle positions with optional post-processing
    
    Note that smoothing length and cube size are given in multiples of the particle radius.
    
    Parameters
    ----------
    particles : numpy.ndarray
        A two-dimensional numpy array of shape (N, 3) containing the positions of the particles.
    attributes_to_interpolate
        Dictionary containing all attributes to interpolate. The keys are the attribute names and the values are the corresponding 1D/2D arrays.
        The arrays must have the same length as the number of particles.
        Supported array types are 2D float32/float64 arrays for vector attributes and 1D uint64/float32/float64 arrays for scalar attributes.
    particle_radius
        Particle radius.
    rest_density
        Rest density of the fluid.
    smoothing_length
        Smoothing length of the SPH kernel in multiples of the particle radius (compact support radius of SPH kernel will be twice the smoothing length).
    cube_size
        Size of the cubes (voxels) used for the marching cubes grid in multiples of the particle radius.
    iso_surface_threshold
        Threshold of the SPH interpolation of the "color field" where the iso surface should be extracted.
    aabb_min
        Lower corner [x,y,z] of the AABB of particles that are active in the reconstruction.
    aabb_max
        Upper corner [x,y,z] of the AABB of particles to consider in the reconstruction.
    multi_threading
        Flag to enable multi-threading for the reconstruction and post-processing steps.
    subdomain_grid
        Flag to enable spatial decomposition by dividing the domain into subdomains with dense marching cube grids for efficient multi-threading.
    subdomain_grid_auto_disable
        Flag to automatically disable the subdomain grid if the global domain is too small.
    subdomain_num_cubes_per_dim
        Number of marching cubes voxels along each coordinate axis in each subdomain if the subdomain grid is enabled.
    check_mesh_closed
        Flag to enable checking the final mesh for holes.
    check_mesh_manifold
        Flag to enable checking the final mesh for non-manifold edges and vertices.
    check_mesh_orientation
        Flag to enable checking the final mesh for inverted triangles (compares angle between vertex normals and adjacent face normals).
    check_mesh_debug
        Flag to enable additional debug output for the check-mesh operations (has no effect if no other check-mesh option is enabled).
    mesh_cleanup
        Flag to enable marching cubes mesh cleanup. This implements the method from "Compact isocontours from sampled data" (Moore, Warren; 1992).
    mesh_cleanup_snap_dist
        If marching cubes mesh cleanup is enabled, this limits vertex snapping to the specified distance relative to the MC edge length (should be in range of [0.0,0.5]).
    decimate_barnacles
        Flag to perform barnacle decimation. For details see "Weighted Laplacian Smoothing for Surface Reconstruction of Particle-based Fluids" (Löschner, Böttcher, Jeske, Bender; 2023).
    keep_vertices
        Flag to retain any vertices without connectivity resulting from mesh cleanup or decimation step instead of filtering them out.
    compute_normals
        Flag to enable computation of vertex normals on the final mesh.
    sph_normals
        Flag to enable computation of normals using SPH interpolation (gradient of the color field) instead of geometry-based normals.
    normals_smoothing_iters
        Number of Laplacian smoothing iterations to perform on the normal field.
    mesh_smoothing_iters
        Number of Laplacian smoothing iterations to perform on the mesh vertices.
    mesh_smoothing_weights
        Flag to enable computation and usage of mesh smoothing weights according to "Weighted Laplacian Smoothing for Surface Reconstruction of Particle-based Fluids" (Löschner, Böttcher, Jeske, Bender; 2023).
    mesh_smoothing_weights_normalization
        Normalization value for the mesh smoothing weights.
    generate_quads
        Flag to enable conversion of triangles to quads depending on geometric criteria.
    quad_max_edge_diag_ratio
        Maximum allowed ratio of quad edge lengths to its diagonals to merge two triangles to a quad (inverse is used for minimum).
    quad_max_normal_angle
        Maximum allowed angle (in degrees) between triangle normals to merge them to a quad.
    quad_max_interior_angle
        Maximum allowed vertex interior angle (in degrees) inside a quad to merge two triangles to a quad.
    output_mesh_smoothing_weights
        Flag to attach and return the smoothing weights as a mesh attribute if smoothing weights are computed.
    output_raw_normals
        Flag to output the raw normals in addition to smoothed normals if smoothing of normals is enabled.
    output_raw_mesh
        Flag to return a copy of the raw mesh before any post-processing steps (inside the returned reconstruction object).
    mesh_aabb_min
        Lower corner [x,y,z] of the axis-aligned bounding box for the mesh, triangles fully outside this box will be removed.
    mesh_aabb_max
        Upper corner [x,y,z] of the axis-aligned bounding box for the mesh, triangles fully outside this box will be removed.
    mesh_aabb_clamp_vertices
        Flag to clamp the vertices of the mesh to the AABB in addition to removing triangles outside the AABB.
    """
