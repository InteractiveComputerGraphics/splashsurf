# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import typing

class Aabb3dF32:
    r"""
    Aabb3d wrapper
    """
    def __new__(cls,min:typing.Sequence[builtins.float], max:typing.Sequence[builtins.float]): ...
    @staticmethod
    def from_points(points:numpy.typing.NDArray[numpy.float32]) -> Aabb3dF32:
        r"""
        Constructs the smallest AABB fitting around all the given points
        """
        ...

    @staticmethod
    def par_from_points(points:numpy.typing.NDArray[numpy.float32]) -> Aabb3dF32:
        r"""
        Constructs the smallest AABB fitting around all the given points, parallel version
        """
        ...

    @staticmethod
    def zeros() -> Aabb3dF32:
        r"""
        Constructs a degenerate AABB with min and max set to zero
        """
        ...

    @staticmethod
    def from_point(point:typing.Sequence[builtins.float]) -> Aabb3dF32:
        r"""
        Constructs a degenerate AABB with zero extents centered at the given point
        """
        ...

    def min(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the min coordinate of the bounding box
        """
        ...

    def max(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the max coordinate of the bounding box
        """
        ...

    def is_consistent(self) -> builtins.bool:
        r"""
        Returns whether the AABB is consistent, i.e. `aabb.min()[i] <= aabb.max()[i]` for all `i`
        """
        ...

    def is_degenerate(self) -> builtins.bool:
        r"""
        Returns whether the AABB is degenerate in any dimension, i.e. `aabb.min()[i] == aabb.max()[i]` for any `i`
        """
        ...

    def extents(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the extents of the bounding box (vector connecting min and max point of the box)
        """
        ...

    def min_extent(self) -> builtins.float:
        r"""
        Returns the smallest scalar extent of the AABB over all of its dimensions
        """
        ...

    def max_extent(self) -> builtins.float:
        r"""
        Returns the largest scalar extent of the AABB over all of its dimensions
        """
        ...

    def centroid(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the geometric centroid of the AABB (mean of the corner points)
        """
        ...

    def contains_aabb(self, other:Aabb3dF32) -> builtins.bool:
        r"""
        Checks if the given AABB is inside of the AABB, the AABB is considered to be half-open to its max coordinate
        """
        ...

    def contains_point(self, point:typing.Sequence[builtins.float]) -> builtins.bool:
        r"""
        Checks if the given point is inside of the AABB, the AABB is considered to be half-open to its max coordinate
        """
        ...

    def translate(self, vector:typing.Sequence[builtins.float]) -> None:
        r"""
        Translates the AABB by the given vector
        """
        ...

    def center_at_origin(self) -> None:
        r"""
        Translates the AABB to center it at the coordinate origin (moves the centroid to the coordinate origin)
        """
        ...

    def scale_uniformly(self, scaling:builtins.float) -> None:
        r"""
        Multiplies a uniform, local scaling to the AABB (i.e. multiplying its extents as if it was centered at the origin)
        """
        ...

    def join(self, other:Aabb3dF32) -> None:
        r"""
        Enlarges this AABB to the smallest AABB enclosing both itself and another AABB
        """
        ...

    def join_with_point(self, point:typing.Sequence[builtins.float]) -> None:
        r"""
        Enlarges this AABB to the smallest AABB enclosing both itself and another point
        """
        ...

    def grow_uniformly(self, margin:builtins.float) -> None:
        r"""
        Grows this AABB uniformly in all directions by the given scalar margin (i.e. adding the margin to min/max extents)
        """
        ...

    def enclosing_cube(self) -> Aabb3dF32:
        r"""
        Returns the smallest cubical AABB with the same center that encloses this AABB
        """
        ...


class Aabb3dF64:
    r"""
    Aabb3d wrapper
    """
    def __new__(cls,min:typing.Sequence[builtins.float], max:typing.Sequence[builtins.float]): ...
    @staticmethod
    def from_points(points:numpy.typing.NDArray[numpy.float64]) -> Aabb3dF64:
        r"""
        Constructs the smallest AABB fitting around all the given points
        """
        ...

    @staticmethod
    def par_from_points(points:numpy.typing.NDArray[numpy.float64]) -> Aabb3dF64:
        r"""
        Constructs the smallest AABB fitting around all the given points, parallel version
        """
        ...

    @staticmethod
    def zeros() -> Aabb3dF64:
        r"""
        Constructs a degenerate AABB with min and max set to zero
        """
        ...

    @staticmethod
    def from_point(point:typing.Sequence[builtins.float]) -> Aabb3dF64:
        r"""
        Constructs a degenerate AABB with zero extents centered at the given point
        """
        ...

    def min(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the min coordinate of the bounding box
        """
        ...

    def max(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the max coordinate of the bounding box
        """
        ...

    def is_consistent(self) -> builtins.bool:
        r"""
        Returns whether the AABB is consistent, i.e. `aabb.min()[i] <= aabb.max()[i]` for all `i`
        """
        ...

    def is_degenerate(self) -> builtins.bool:
        r"""
        Returns whether the AABB is degenerate in any dimension, i.e. `aabb.min()[i] == aabb.max()[i]` for any `i`
        """
        ...

    def extents(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the extents of the bounding box (vector connecting min and max point of the box)
        """
        ...

    def min_extent(self) -> builtins.float:
        r"""
        Returns the smallest scalar extent of the AABB over all of its dimensions
        """
        ...

    def max_extent(self) -> builtins.float:
        r"""
        Returns the largest scalar extent of the AABB over all of its dimensions
        """
        ...

    def centroid(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the geometric centroid of the AABB (mean of the corner points)
        """
        ...

    def contains_aabb(self, other:Aabb3dF64) -> builtins.bool:
        r"""
        Checks if the given AABB is inside of the AABB, the AABB is considered to be half-open to its max coordinate
        """
        ...

    def contains_point(self, point:typing.Sequence[builtins.float]) -> builtins.bool:
        r"""
        Checks if the given point is inside of the AABB, the AABB is considered to be half-open to its max coordinate
        """
        ...

    def translate(self, vector:typing.Sequence[builtins.float]) -> None:
        r"""
        Translates the AABB by the given vector
        """
        ...

    def center_at_origin(self) -> None:
        r"""
        Translates the AABB to center it at the coordinate origin (moves the centroid to the coordinate origin)
        """
        ...

    def scale_uniformly(self, scaling:builtins.float) -> None:
        r"""
        Multiplies a uniform, local scaling to the AABB (i.e. multiplying its extents as if it was centered at the origin)
        """
        ...

    def join(self, other:Aabb3dF64) -> None:
        r"""
        Enlarges this AABB to the smallest AABB enclosing both itself and another AABB
        """
        ...

    def join_with_point(self, point:typing.Sequence[builtins.float]) -> None:
        r"""
        Enlarges this AABB to the smallest AABB enclosing both itself and another point
        """
        ...

    def grow_uniformly(self, margin:builtins.float) -> None:
        r"""
        Grows this AABB uniformly in all directions by the given scalar margin (i.e. adding the margin to min/max extents)
        """
        ...

    def enclosing_cube(self) -> Aabb3dF64:
        r"""
        Returns the smallest cubical AABB with the same center that encloses this AABB
        """
        ...


class MixedTriQuadMesh3dF32:
    r"""
    MixedTriQuadMesh3d wrapper
    """
    vertices: numpy.typing.NDArray[numpy.float32]
    cells: builtins.list[builtins.list[builtins.int]]
    def take_vertices_and_cells(self) -> tuple:
        r"""
        Returns a tuple of vertices and triangles without copying the data, removes the data in the class
        """
        ...


class MixedTriQuadMesh3dF64:
    r"""
    MixedTriQuadMesh3d wrapper
    """
    vertices: numpy.typing.NDArray[numpy.float64]
    cells: builtins.list[builtins.list[builtins.int]]
    def take_vertices_and_cells(self) -> tuple:
        r"""
        Returns a tuple of vertices and triangles without copying the data, removes the data in the class
        """
        ...


class MixedTriQuadMeshWithDataF32:
    r"""
    MeshWithData wrapper
    """
    mesh: MixedTriQuadMesh3dF32
    def __new__(cls,mesh:MixedTriQuadMesh3dF32): ...
    def take_mesh(self) -> MixedTriQuadMesh3dF32:
        r"""
        Returns mesh without copying the mesh data, removes it from the object
        """
        ...

    def par_clamp_with_aabb(self, aabb:Aabb3dF32, clamp_vertices:builtins.bool, keep_vertices:builtins.bool) -> MixedTriQuadMeshWithDataF32:
        r"""
        Removes all cells from the mesh that are completely outside of the given AABB and clamps the remaining cells to the boundary
        """
        ...

    def push_point_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None:
        ...

    def push_point_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None:
        ...

    def push_point_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float32]) -> None:
        ...

    def push_cell_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None:
        ...

    def push_cell_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None:
        ...

    def push_cell_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float32]) -> None:
        ...

    def get_point_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh vertex attribute by name
        """
        ...

    def get_cell_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh cell attribute by name
        """
        ...

    def get_point_attributes(self) -> dict:
        r"""
        Get all point attributes in a python dictionary
        """
        ...

    def get_cell_attributes(self) -> dict:
        r"""
        Get all cell attributes in a python dictionary
        """
        ...

    def get_point_attribute_keys(self) -> list:
        r"""
        Get all registered point attribute names
        """
        ...

    def get_cell_attribute_keys(self) -> list:
        r"""
        Get all registered cell attribute names
        """
        ...


class MixedTriQuadMeshWithDataF64:
    r"""
    MeshWithData wrapper
    """
    mesh: MixedTriQuadMesh3dF64
    def __new__(cls,mesh:MixedTriQuadMesh3dF64): ...
    def take_mesh(self) -> MixedTriQuadMesh3dF64:
        r"""
        Returns mesh without copying the mesh data, removes it from the object
        """
        ...

    def par_clamp_with_aabb(self, aabb:Aabb3dF64, clamp_vertices:builtins.bool, keep_vertices:builtins.bool) -> MixedTriQuadMeshWithDataF64:
        r"""
        Removes all cells from the mesh that are completely outside of the given AABB and clamps the remaining cells to the boundary
        """
        ...

    def push_point_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None:
        ...

    def push_point_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None:
        ...

    def push_point_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float64]) -> None:
        ...

    def push_cell_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None:
        ...

    def push_cell_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None:
        ...

    def push_cell_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float64]) -> None:
        ...

    def get_point_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh vertex attribute by name
        """
        ...

    def get_cell_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh cell attribute by name
        """
        ...

    def get_point_attributes(self) -> dict:
        r"""
        Get all point attributes in a python dictionary
        """
        ...

    def get_cell_attributes(self) -> dict:
        r"""
        Get all cell attributes in a python dictionary
        """
        ...

    def get_point_attribute_keys(self) -> list:
        r"""
        Get all registered point attribute names
        """
        ...

    def get_cell_attribute_keys(self) -> list:
        r"""
        Get all registered cell attribute names
        """
        ...


class SphInterpolatorF32:
    r"""
    SphInterpolator wrapper
    """
    def __new__(cls,particle_positions:numpy.typing.NDArray[numpy.float32], particle_densities:typing.Sequence[builtins.float], particle_rest_mass:builtins.float, compact_support_radius:builtins.float): ...
    def interpolate_scalar_quantity(self, particle_quantity:typing.Sequence[builtins.float], interpolation_points:numpy.typing.NDArray[numpy.float32], first_order_correction:builtins.bool) -> builtins.list[builtins.float]:
        r"""
        Interpolates a scalar per particle quantity to the given points, panics if the there are less per-particles values than particles
        """
        ...

    def interpolate_normals(self, interpolation_points:numpy.typing.NDArray[numpy.float32]) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Interpolates surface normals (i.e. normalized SPH gradient of the indicator function) of the fluid to the given points using SPH interpolation
        """
        ...

    def interpolate_vector_quantity(self, particle_quantity:numpy.typing.NDArray[numpy.float32], interpolation_points:numpy.typing.NDArray[numpy.float32], first_order_correction:builtins.bool) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Interpolates a vectorial per particle quantity to the given points, panics if the there are less per-particles values than particles
        """
        ...


class SphInterpolatorF64:
    r"""
    SphInterpolator wrapper
    """
    def __new__(cls,particle_positions:numpy.typing.NDArray[numpy.float64], particle_densities:typing.Sequence[builtins.float], particle_rest_mass:builtins.float, compact_support_radius:builtins.float): ...
    def interpolate_scalar_quantity(self, particle_quantity:typing.Sequence[builtins.float], interpolation_points:numpy.typing.NDArray[numpy.float64], first_order_correction:builtins.bool) -> builtins.list[builtins.float]:
        r"""
        Interpolates a scalar per particle quantity to the given points, panics if the there are less per-particles values than particles
        """
        ...

    def interpolate_normals(self, interpolation_points:numpy.typing.NDArray[numpy.float64]) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Interpolates surface normals (i.e. normalized SPH gradient of the indicator function) of the fluid to the given points using SPH interpolation
        """
        ...

    def interpolate_vector_quantity(self, particle_quantity:numpy.typing.NDArray[numpy.float64], interpolation_points:numpy.typing.NDArray[numpy.float64], first_order_correction:builtins.bool) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Interpolates a vectorial per particle quantity to the given points, panics if the there are less per-particles values than particles
        """
        ...


class SurfaceReconstructionF32:
    r"""
    SurfaceReconstruction wrapper
    """
    mesh: TriMesh3dF32
    grid: UniformGridF32
    def particle_densities(self) -> builtins.list[builtins.float]:
        r"""
        Returns a reference to the global particle density vector if computed during the reconstruction (currently, all reconstruction approaches return this)
        """
        ...

    def particle_neighbors(self) -> typing.Optional[builtins.list[builtins.list[builtins.int]]]:
        r"""
        Returns a reference to the global list of per-particle neighborhood lists if computed during the reconstruction (`None` if not specified in the parameters)
        """
        ...


class SurfaceReconstructionF64:
    r"""
    SurfaceReconstruction wrapper
    """
    mesh: TriMesh3dF64
    grid: UniformGridF64
    def particle_densities(self) -> builtins.list[builtins.float]:
        r"""
        Returns a reference to the global particle density vector if computed during the reconstruction (currently, all reconstruction approaches return this)
        """
        ...

    def particle_neighbors(self) -> typing.Optional[builtins.list[builtins.list[builtins.int]]]:
        r"""
        Returns a reference to the global list of per-particle neighborhood lists if computed during the reconstruction (`None` if not specified in the parameters)
        """
        ...


class TriMesh3dF32:
    r"""
    TriMesh3d wrapper
    """
    vertices: numpy.typing.NDArray[numpy.float32]
    triangles: numpy.typing.NDArray[numpy.uint64]
    def take_vertices_and_triangles(self) -> tuple:
        r"""
        Returns a tuple of vertices and triangles without copying the data, removes the data in the class
        """
        ...

    def par_vertex_normals(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Computes the mesh's vertex normals using an area weighted average of the adjacent triangle faces (parallelized version)
        """
        ...

    def vertex_vertex_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a mapping of all mesh vertices to the set of their connected neighbor vertices
        """
        ...


class TriMesh3dF64:
    r"""
    TriMesh3d wrapper
    """
    vertices: numpy.typing.NDArray[numpy.float64]
    triangles: numpy.typing.NDArray[numpy.uint64]
    def take_vertices_and_triangles(self) -> tuple:
        r"""
        Returns a tuple of vertices and triangles without copying the data, removes the data in the class
        """
        ...

    def par_vertex_normals(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Computes the mesh's vertex normals using an area weighted average of the adjacent triangle faces (parallelized version)
        """
        ...

    def vertex_vertex_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a mapping of all mesh vertices to the set of their connected neighbor vertices
        """
        ...


class TriMeshWithDataF32:
    r"""
    MeshWithData wrapper
    """
    mesh: TriMesh3dF32
    def __new__(cls,mesh:TriMesh3dF32): ...
    def take_mesh(self) -> TriMesh3dF32:
        r"""
        Returns mesh without copying the mesh data, removes it from the object
        """
        ...

    def par_clamp_with_aabb(self, aabb:Aabb3dF32, clamp_vertices:builtins.bool, keep_vertices:builtins.bool) -> TriMeshWithDataF32:
        r"""
        Removes all cells from the mesh that are completely outside of the given AABB and clamps the remaining cells to the boundary
        """
        ...

    def push_point_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None:
        ...

    def push_point_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None:
        ...

    def push_point_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float32]) -> None:
        ...

    def push_cell_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None:
        ...

    def push_cell_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None:
        ...

    def push_cell_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float32]) -> None:
        ...

    def get_point_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh vertex attribute by name
        """
        ...

    def get_cell_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh cell attribute by name
        """
        ...

    def get_point_attributes(self) -> dict:
        r"""
        Get all point attributes in a python dictionary
        """
        ...

    def get_cell_attributes(self) -> dict:
        r"""
        Get all cell attributes in a python dictionary
        """
        ...

    def get_point_attribute_keys(self) -> list:
        r"""
        Get all registered point attribute names
        """
        ...

    def get_cell_attribute_keys(self) -> list:
        r"""
        Get all registered cell attribute names
        """
        ...


class TriMeshWithDataF64:
    r"""
    MeshWithData wrapper
    """
    mesh: TriMesh3dF64
    def __new__(cls,mesh:TriMesh3dF64): ...
    def take_mesh(self) -> TriMesh3dF64:
        r"""
        Returns mesh without copying the mesh data, removes it from the object
        """
        ...

    def par_clamp_with_aabb(self, aabb:Aabb3dF64, clamp_vertices:builtins.bool, keep_vertices:builtins.bool) -> TriMeshWithDataF64:
        r"""
        Removes all cells from the mesh that are completely outside of the given AABB and clamps the remaining cells to the boundary
        """
        ...

    def push_point_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None:
        ...

    def push_point_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None:
        ...

    def push_point_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float64]) -> None:
        ...

    def push_cell_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None:
        ...

    def push_cell_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None:
        ...

    def push_cell_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float64]) -> None:
        ...

    def get_point_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh vertex attribute by name
        """
        ...

    def get_cell_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh cell attribute by name
        """
        ...

    def get_point_attributes(self) -> dict:
        r"""
        Get all point attributes in a python dictionary
        """
        ...

    def get_cell_attributes(self) -> dict:
        r"""
        Get all cell attributes in a python dictionary
        """
        ...

    def get_point_attribute_keys(self) -> list:
        r"""
        Get all registered point attribute names
        """
        ...

    def get_cell_attribute_keys(self) -> list:
        r"""
        Get all registered cell attribute names
        """
        ...


class UniformGridF32:
    r"""
    UniformGrid wrapper
    """
    ...

class UniformGridF64:
    r"""
    UniformGrid wrapper
    """
    ...

