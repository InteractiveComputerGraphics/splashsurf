# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

from __future__ import annotations

import builtins
import numpy
import numpy.typing
import typing
from enum import Enum

class Aabb3d:
    r"""
    Three-dimensional axis-aligned bounding box defined by its minimum and maximum corners
    """
    @property
    def min(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        The min coordinate of the AABB
        """
    @property
    def max(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        The max coordinate of the AABB
        """
    @staticmethod
    def from_min_max(min:typing.Sequence[builtins.float], max:typing.Sequence[builtins.float]) -> Aabb3d:
        r"""
        Constructs an AABB with the given min and max coordinates
        """
    @staticmethod
    def from_points(points:numpy.typing.NDArray[typing.Any]) -> Aabb3d:
        r"""
        Constructs the smallest AABB fitting around all the given points
        """
    def contains_point(self, point:typing.Sequence[builtins.float]) -> builtins.bool:
        r"""
        Checks if the given point is inside the AABB, the AABB is considered to be half-open to its max coordinate
        """

class MeshAttribute:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the data stored in the attribute
        """
    @property
    def name(self) -> builtins.str:
        r"""
        Name of the attribute
        """
    @property
    def data(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        View of the attribute data as a numpy array
        """

class MeshWithData:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either `np.float32` or `np.float64`)
        """
    @property
    def mesh_type(self) -> MeshType:
        r"""
        Type of the underlying mesh
        """
    @property
    def point_attributes(self) -> dict[str, numpy.typing.NDArray]:
        r"""
        The attributes attached points (vertices) of the mesh
        """
    @property
    def cell_attributes(self) -> dict[str, numpy.typing.NDArray]:
        r"""
        The attributes attached to the cells (triangles or quads) of the mesh
        """
    @property
    def mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        The contained mesh without associated data and attributes
        """
    def copy_mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        Returns a copy of the contained mesh without associated data and attributes
        """

class MixedTriQuadMesh3d:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either `np.float32` or `np.float64`)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    def get_triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all triangle cells of the mesh as an `Nx3` array of vertex indices
        """
    def get_quads(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all quad cells of the mesh as an `Nx4` array of vertex indices
        """

class NeighborhoodLists:
    def __len__(self) -> builtins.int:
        r"""
        Returns the number of particles for which neighborhood lists are stored
        """
    def __getitem__(self, idx:builtins.int) -> builtins.list[builtins.int]:
        r"""
        Returns the neighborhood list for the particle at the given index
        """
    def get_neighborhood_lists(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns all stored neighborhood lists as a list of lists
        """

class SphInterpolator:
    def __new__(cls, particle_positions:numpy.typing.NDArray[typing.Any], particle_densities:numpy.typing.NDArray[typing.Any], particle_rest_mass:builtins.float, compact_support_radius:builtins.float) -> SphInterpolator:
        r"""
        Constructs an SPH interpolator (with cubic kernels) for the given particles
        """
    def interpolate_quantity(self, particle_quantity:numpy.typing.NDArray[typing.Any], interpolation_points:numpy.typing.NDArray[typing.Any], *, first_order_correction:builtins.bool=False) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Interpolates a scalar or vectorial per particle quantity to the given points
        """
    def interpolate_normals(self, interpolation_points:numpy.typing.NDArray[typing.Any]) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Interpolates surface normals (i.e. normalized SPH gradient of the indicator function) of the fluid to the given points using SPH interpolation
        """

class SurfaceReconstruction:
    @property
    def grid(self) -> UniformGrid:
        r"""
        The marching cubes grid parameters used for the surface reconstruction
        """
    @property
    def particle_densities(self) -> typing.Optional[numpy.typing.NDArray[typing.Any]]:
        r"""
        The global array of particle densities (`None` if they were only computed locally)
        """
    @property
    def particle_inside_aabb(self) -> typing.Optional[numpy.typing.NDArray[typing.Any]]:
        r"""
        A boolean array indicating whether each particle was inside the AABB used for the reconstruction (`None` if no AABB was set)
        """
    @property
    def particle_neighbors(self) -> typing.Optional[NeighborhoodLists]:
        r"""
        The global neighborhood lists per particle (`None` if they were only computed locally)
        """
    @property
    def mesh(self) -> TriMesh3d:
        r"""
        The reconstructed triangle mesh
        """

class TriMesh3d:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either `np.float32` or `np.float64`)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    @property
    def triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        The `Mx3` array of vertex indices per triangle
        """
    def vertex_normals_parallel(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Computes the vertex normals of the mesh using an area weighted average of the adjacent triangle faces
        """
    def vertex_vertex_connectivity(self) -> VertexVertexConnectivity:
        r"""
        Computes the vertex-vertex connectivity of the mesh
        """

class UniformGrid:
    r"""
    Struct containing the parameters of the uniform grid used for the surface reconstruction
    """
    ...

class VertexVertexConnectivity:
    r"""
    Vertex-vertex connectivity of a mesh
    """
    def copy_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a copy of the contained connectivity data
        """
    def take_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns the contained connectivity data by moving it out of this object (zero copy)
        """

class MeshType(Enum):
    r"""
    Enum specifying the type of mesh contained in a `MeshWithData`
    """
    Tri3d = ...
    r"""
    3D triangle mesh
    """
    MixedTriQuad3d = ...
    r"""
    3D mixed triangle and quad mesh
    """

def barnacle_decimation(mesh:typing.Union[TriMesh3d, MeshWithData], *, keep_vertices:builtins.bool) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs specialized decimation on the given mesh to prevent "barnacles" when applying weighted Laplacian smoothing
    
    The decimation is performed inplace and modifies the given mesh.
    Returns the vertex-vertex connectivity of the decimated mesh which can be used for other
    post-processing steps.
    """

def check_mesh_consistency(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, check_closed:builtins.bool=True, check_manifold:builtins.bool=True, debug:builtins.bool=False) -> typing.Optional[builtins.str]:
    r"""
    Checks the consistency of a reconstructed surface mesh (watertightness, manifoldness), optionally returns a string with details if problems are found
    """

def convert_tris_to_quads(mesh:typing.Union[TriMesh3d, MeshWithData], *, non_squareness_limit:builtins.float=1.75, normal_angle_limit:builtins.float=10.0, max_interior_angle:builtins.float=135.0) -> typing.Union[MixedTriQuadMesh3d, MeshWithData]:
    r"""
    Converts triangles to quads by merging triangles sharing an edge if they fulfill the given criteria
    
    This operation creates a new mesh and does not modify the input mesh.
    Angles are specified in degrees.
    """

def laplacian_smoothing_normals_parallel(normals:numpy.typing.NDArray[typing.Any], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int) -> None:
    r"""
    Laplacian smoothing of a normal field
    
    The smoothing is performed inplace and modifies the given normal array.
    """

def laplacian_smoothing_parallel(mesh:typing.Union[TriMesh3d, MeshWithData], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int, beta:builtins.float=1.0, weights:numpy.typing.NDArray[typing.Any]) -> None:
    r"""
    Laplacian smoothing of mesh vertices with feature weights
    
    The smoothing is performed inplace and modifies the vertices of the given mesh.
    """

def marching_cubes_cleanup(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, max_rel_snap_dist:typing.Optional[builtins.float]=None, max_iter:builtins.int=5, keep_vertices:builtins.bool=False) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs simplification on the given mesh designed for marching cubes reconstructions inspired by the "Compact Contouring"/"Mesh displacement" approach by Doug Moore and Joe Warren
    
    The simplification is performed inplace and modifies the given mesh.
    """

def neighborhood_search_spatial_hashing_parallel(particle_positions:numpy.typing.NDArray[typing.Any], domain:Aabb3d, search_radius:builtins.float) -> NeighborhoodLists:
    r"""
    Performs a neighborhood search using spatial hashing (multithreaded implementation)
    """

def reconstruct_surface(particles:numpy.typing.NDArray[typing.Any], *, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, multi_threading:builtins.bool=True, global_neighborhood_list:builtins.bool=False, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None) -> SurfaceReconstruction:
    r"""
    Performs a surface reconstruction from the given particles without additional post-processing
    
    Note that all parameters use absolute distance units and are not relative to the particle radius.
    """

def reconstruction_pipeline(particles:numpy.typing.NDArray[typing.Any], *, attributes_to_interpolate:typing.Optional[dict]=None, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, multi_threading:builtins.bool=True, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64, check_mesh_closed:builtins.bool=False, check_mesh_manifold:builtins.bool=False, check_mesh_orientation:builtins.bool=False, check_mesh_debug:builtins.bool=False, mesh_cleanup:builtins.bool=False, mesh_cleanup_snap_dist:typing.Optional[builtins.float]=None, decimate_barnacles:builtins.bool=False, keep_vertices:builtins.bool=False, compute_normals:builtins.bool=False, sph_normals:builtins.bool=False, normals_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_weights:builtins.bool=True, mesh_smoothing_weights_normalization:builtins.float=13.0, generate_quads:builtins.bool=False, quad_max_edge_diag_ratio:builtins.float=1.75, quad_max_normal_angle:builtins.float=10.0, quad_max_interior_angle:builtins.float=135.0, output_mesh_smoothing_weights:builtins.bool=False, output_raw_normals:builtins.bool=False, output_raw_mesh:builtins.bool=False, mesh_aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_clamp_vertices:builtins.bool=True, dtype:typing.Optional[numpy.dtype]=None) -> tuple[MeshWithData, SurfaceReconstruction]:
    r"""
    Runs the surface reconstruction pipeline for the given particle positions with optional post-processing
    
    Note that smoothing length and cube size are given in multiples of the particle radius.
    """

def triangulate_density_map(values:numpy.typing.NDArray[typing.Any], grid:UniformGrid, *, iso_surface_threshold:builtins.float) -> TriMesh3d: ...
