# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import typing
from enum import Enum

class Aabb3dF32:
    r"""
    Aabb3d wrapper
    """
    def __new__(cls, min:typing.Sequence[builtins.float], max:typing.Sequence[builtins.float]) -> Aabb3dF32: ...
    @staticmethod
    def from_points(points:numpy.typing.NDArray[numpy.float32]) -> Aabb3dF32:
        r"""
        Constructs the smallest AABB fitting around all the given points
        """
    @staticmethod
    def par_from_points(points:numpy.typing.NDArray[numpy.float32]) -> Aabb3dF32:
        r"""
        Constructs the smallest AABB fitting around all the given points, parallel version
        """
    @staticmethod
    def zeros() -> Aabb3dF32:
        r"""
        Constructs a degenerate AABB with min and max set to zero
        """
    @staticmethod
    def from_point(point:typing.Sequence[builtins.float]) -> Aabb3dF32:
        r"""
        Constructs a degenerate AABB with zero extents centered at the given point
        """
    def min(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the min coordinate of the bounding box
        """
    def max(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the max coordinate of the bounding box
        """
    def is_consistent(self) -> builtins.bool:
        r"""
        Returns whether the AABB is consistent, i.e. `aabb.min()[i] <= aabb.max()[i]` for all `i`
        """
    def is_degenerate(self) -> builtins.bool:
        r"""
        Returns whether the AABB is degenerate in any dimension, i.e. `aabb.min()[i] == aabb.max()[i]` for any `i`
        """
    def extents(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the extents of the bounding box (vector connecting min and max point of the box)
        """
    def min_extent(self) -> builtins.float:
        r"""
        Returns the smallest scalar extent of the AABB over all of its dimensions
        """
    def max_extent(self) -> builtins.float:
        r"""
        Returns the largest scalar extent of the AABB over all of its dimensions
        """
    def centroid(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the geometric centroid of the AABB (mean of the corner points)
        """
    def contains_aabb(self, other:Aabb3dF32) -> builtins.bool:
        r"""
        Checks if the given AABB is inside of the AABB, the AABB is considered to be half-open to its max coordinate
        """
    def contains_point(self, point:typing.Sequence[builtins.float]) -> builtins.bool:
        r"""
        Checks if the given point is inside of the AABB, the AABB is considered to be half-open to its max coordinate
        """
    def translate(self, vector:typing.Sequence[builtins.float]) -> None:
        r"""
        Translates the AABB by the given vector
        """
    def center_at_origin(self) -> None:
        r"""
        Translates the AABB to center it at the coordinate origin (moves the centroid to the coordinate origin)
        """
    def scale_uniformly(self, scaling:builtins.float) -> None:
        r"""
        Multiplies a uniform, local scaling to the AABB (i.e. multiplying its extents as if it was centered at the origin)
        """
    def join(self, other:Aabb3dF32) -> None:
        r"""
        Enlarges this AABB to the smallest AABB enclosing both itself and another AABB
        """
    def join_with_point(self, point:typing.Sequence[builtins.float]) -> None:
        r"""
        Enlarges this AABB to the smallest AABB enclosing both itself and another point
        """
    def grow_uniformly(self, margin:builtins.float) -> None:
        r"""
        Grows this AABB uniformly in all directions by the given scalar margin (i.e. adding the margin to min/max extents)
        """
    def enclosing_cube(self) -> Aabb3dF32:
        r"""
        Returns the smallest cubical AABB with the same center that encloses this AABB
        """

class Aabb3dF64:
    r"""
    Aabb3d wrapper
    """
    def __new__(cls, min:typing.Sequence[builtins.float], max:typing.Sequence[builtins.float]) -> Aabb3dF64: ...
    @staticmethod
    def from_points(points:numpy.typing.NDArray[numpy.float64]) -> Aabb3dF64:
        r"""
        Constructs the smallest AABB fitting around all the given points
        """
    @staticmethod
    def par_from_points(points:numpy.typing.NDArray[numpy.float64]) -> Aabb3dF64:
        r"""
        Constructs the smallest AABB fitting around all the given points, parallel version
        """
    @staticmethod
    def zeros() -> Aabb3dF64:
        r"""
        Constructs a degenerate AABB with min and max set to zero
        """
    @staticmethod
    def from_point(point:typing.Sequence[builtins.float]) -> Aabb3dF64:
        r"""
        Constructs a degenerate AABB with zero extents centered at the given point
        """
    def min(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the min coordinate of the bounding box
        """
    def max(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the max coordinate of the bounding box
        """
    def is_consistent(self) -> builtins.bool:
        r"""
        Returns whether the AABB is consistent, i.e. `aabb.min()[i] <= aabb.max()[i]` for all `i`
        """
    def is_degenerate(self) -> builtins.bool:
        r"""
        Returns whether the AABB is degenerate in any dimension, i.e. `aabb.min()[i] == aabb.max()[i]` for any `i`
        """
    def extents(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the extents of the bounding box (vector connecting min and max point of the box)
        """
    def min_extent(self) -> builtins.float:
        r"""
        Returns the smallest scalar extent of the AABB over all of its dimensions
        """
    def max_extent(self) -> builtins.float:
        r"""
        Returns the largest scalar extent of the AABB over all of its dimensions
        """
    def centroid(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the geometric centroid of the AABB (mean of the corner points)
        """
    def contains_aabb(self, other:Aabb3dF64) -> builtins.bool:
        r"""
        Checks if the given AABB is inside of the AABB, the AABB is considered to be half-open to its max coordinate
        """
    def contains_point(self, point:typing.Sequence[builtins.float]) -> builtins.bool:
        r"""
        Checks if the given point is inside of the AABB, the AABB is considered to be half-open to its max coordinate
        """
    def translate(self, vector:typing.Sequence[builtins.float]) -> None:
        r"""
        Translates the AABB by the given vector
        """
    def center_at_origin(self) -> None:
        r"""
        Translates the AABB to center it at the coordinate origin (moves the centroid to the coordinate origin)
        """
    def scale_uniformly(self, scaling:builtins.float) -> None:
        r"""
        Multiplies a uniform, local scaling to the AABB (i.e. multiplying its extents as if it was centered at the origin)
        """
    def join(self, other:Aabb3dF64) -> None:
        r"""
        Enlarges this AABB to the smallest AABB enclosing both itself and another AABB
        """
    def join_with_point(self, point:typing.Sequence[builtins.float]) -> None:
        r"""
        Enlarges this AABB to the smallest AABB enclosing both itself and another point
        """
    def grow_uniformly(self, margin:builtins.float) -> None:
        r"""
        Grows this AABB uniformly in all directions by the given scalar margin (i.e. adding the margin to min/max extents)
        """
    def enclosing_cube(self) -> Aabb3dF64:
        r"""
        Returns the smallest cubical AABB with the same center that encloses this AABB
        """

class MeshAttribute:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the data stored in the attribute
        """
    @property
    def name(self) -> builtins.str:
        r"""
        Name of the attribute
        """
    @property
    def data(self) -> None:
        r"""
        View of the attribute data as a numpy array
        """

class MeshWithData:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either `np.float32` or `np.float64`)
        """
    @property
    def mesh_type(self) -> MeshType:
        r"""
        Returns the type of the underlying mesh
        """
    @property
    def point_attributes(self) -> typing.List[MeshAttribute]: ...
    @property
    def cell_attributes(self) -> typing.List[MeshAttribute]: ...
    @property
    def mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        The contained mesh without associated data and attributes
        """
    def as_tri3d(self) -> typing.Optional[TriMesh3d]: ...
    def as_mixed_tri_quad3d(self) -> typing.Optional[MixedTriQuadMesh3d]: ...
    def copy_mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        Returns a copy of the contained mesh without associated data and attributes
        """

class MixedTriQuadMesh3d:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either `np.float32` or `np.float64`)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    def get_triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all triangle cells of the mesh as an `Nx3` array of vertex indices
        """
    def get_quads(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all quad cells of the mesh as an `Nx3` array of vertex indices
        """

class MixedTriQuadMesh3dF32:
    r"""
    MixedTriQuadMesh3d wrapper
    """
    def get_vertices(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns a copy of the `Nx3` array of vertex positions
        """
    def get_cells(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a 2D list specifying the vertex indices either for a triangle or a quad
        """
    def take_vertices(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the `Nx3` array of vertex positions by moving it out of the mesh (zero copy)
        """

class MixedTriQuadMesh3dF64:
    r"""
    MixedTriQuadMesh3d wrapper
    """
    def get_vertices(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns a copy of the `Nx3` array of vertex positions
        """
    def get_cells(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a 2D list specifying the vertex indices either for a triangle or a quad
        """
    def take_vertices(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the `Nx3` array of vertex positions by moving it out of the mesh (zero copy)
        """

class MixedTriQuadMeshWithDataF32:
    r"""
    MeshWithData wrapper
    """
    def __new__(cls, mesh:MixedTriQuadMesh3dF32) -> MixedTriQuadMeshWithDataF32: ...
    def get_mesh(self) -> MixedTriQuadMesh3dF32:
        r"""
        Returns a copy of the contained mesh
        """
    def take_mesh(self) -> MixedTriQuadMesh3dF32:
        r"""
        Returns the contained mesh by moving it out of this object (zero copy)
        """
    def par_clamp_with_aabb(self, aabb:Aabb3dF32, clamp_vertices:builtins.bool, keep_vertices:builtins.bool) -> MixedTriQuadMeshWithDataF32:
        r"""
        Removes all cells from the mesh that are completely outside of the given AABB and clamps the remaining cells to the boundary
        """
    def push_point_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None: ...
    def push_point_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None: ...
    def push_point_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float32]) -> None: ...
    def push_cell_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None: ...
    def push_cell_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None: ...
    def push_cell_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float32]) -> None: ...
    def get_point_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh vertex attribute by name
        """
    def get_cell_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh cell attribute by name
        """
    def get_point_attributes(self) -> dict:
        r"""
        Get all point attributes in a python dictionary
        """
    def get_cell_attributes(self) -> dict:
        r"""
        Get all cell attributes in a python dictionary
        """
    def get_point_attribute_keys(self) -> list:
        r"""
        Get all registered point attribute names
        """
    def get_cell_attribute_keys(self) -> list:
        r"""
        Get all registered cell attribute names
        """

class MixedTriQuadMeshWithDataF64:
    r"""
    MeshWithData wrapper
    """
    def __new__(cls, mesh:MixedTriQuadMesh3dF64) -> MixedTriQuadMeshWithDataF64: ...
    def get_mesh(self) -> MixedTriQuadMesh3dF64:
        r"""
        Returns a copy of the contained mesh
        """
    def take_mesh(self) -> MixedTriQuadMesh3dF64:
        r"""
        Returns the contained mesh by moving it out of this object (zero copy)
        """
    def par_clamp_with_aabb(self, aabb:Aabb3dF64, clamp_vertices:builtins.bool, keep_vertices:builtins.bool) -> MixedTriQuadMeshWithDataF64:
        r"""
        Removes all cells from the mesh that are completely outside of the given AABB and clamps the remaining cells to the boundary
        """
    def push_point_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None: ...
    def push_point_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None: ...
    def push_point_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float64]) -> None: ...
    def push_cell_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None: ...
    def push_cell_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None: ...
    def push_cell_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float64]) -> None: ...
    def get_point_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh vertex attribute by name
        """
    def get_cell_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh cell attribute by name
        """
    def get_point_attributes(self) -> dict:
        r"""
        Get all point attributes in a python dictionary
        """
    def get_cell_attributes(self) -> dict:
        r"""
        Get all cell attributes in a python dictionary
        """
    def get_point_attribute_keys(self) -> list:
        r"""
        Get all registered point attribute names
        """
    def get_cell_attribute_keys(self) -> list:
        r"""
        Get all registered cell attribute names
        """

class SphInterpolatorF32:
    r"""
    SphInterpolator wrapper
    """
    def __new__(cls, particle_positions:numpy.typing.NDArray[numpy.float32], particle_densities:typing.Sequence[builtins.float], particle_rest_mass:builtins.float, compact_support_radius:builtins.float) -> SphInterpolatorF32: ...
    def interpolate_scalar_quantity(self, particle_quantity:typing.Sequence[builtins.float], interpolation_points:numpy.typing.NDArray[numpy.float32], first_order_correction:builtins.bool) -> builtins.list[builtins.float]:
        r"""
        Interpolates a scalar per particle quantity to the given points, panics if the there are less per-particles values than particles
        """
    def interpolate_normals(self, interpolation_points:numpy.typing.NDArray[numpy.float32]) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Interpolates surface normals (i.e. normalized SPH gradient of the indicator function) of the fluid to the given points using SPH interpolation
        """
    def interpolate_vector_quantity(self, particle_quantity:numpy.typing.NDArray[numpy.float32], interpolation_points:numpy.typing.NDArray[numpy.float32], first_order_correction:builtins.bool) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Interpolates a vectorial per particle quantity to the given points, panics if the there are less per-particles values than particles
        """

class SphInterpolatorF64:
    r"""
    SphInterpolator wrapper
    """
    def __new__(cls, particle_positions:numpy.typing.NDArray[numpy.float64], particle_densities:typing.Sequence[builtins.float], particle_rest_mass:builtins.float, compact_support_radius:builtins.float) -> SphInterpolatorF64: ...
    def interpolate_scalar_quantity(self, particle_quantity:typing.Sequence[builtins.float], interpolation_points:numpy.typing.NDArray[numpy.float64], first_order_correction:builtins.bool) -> builtins.list[builtins.float]:
        r"""
        Interpolates a scalar per particle quantity to the given points, panics if the there are less per-particles values than particles
        """
    def interpolate_normals(self, interpolation_points:numpy.typing.NDArray[numpy.float64]) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Interpolates surface normals (i.e. normalized SPH gradient of the indicator function) of the fluid to the given points using SPH interpolation
        """
    def interpolate_vector_quantity(self, particle_quantity:numpy.typing.NDArray[numpy.float64], interpolation_points:numpy.typing.NDArray[numpy.float64], first_order_correction:builtins.bool) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Interpolates a vectorial per particle quantity to the given points, panics if the there are less per-particles values than particles
        """

class SurfaceReconstruction:
    r"""
    Struct containing results of the surface reconstruction including the mesh, grid parameters and optional particle data
    """
    def copy_mesh(self) -> TriMesh3d:
        r"""
        Returns a copy of the surface mesh of the reconstruction
        """
    def copy_grid(self) -> UniformGrid:
        r"""
        Returns a copy of the uniform grid parameters used for the reconstruction
        """
    def copy_particle_densities(self) -> typing.Optional[numpy.typing.NDArray[typing.Any]]:
        r"""
        Returns a copy of the particle densities computed during the reconstruction
        """
    def copy_particle_neighbors(self) -> typing.Optional[builtins.list[builtins.list[builtins.int]]]:
        r"""
        Returns a copy of the per-particle neighborhood lists computed during the reconstruction if available
        
        The neighborhood lists are only available if the flag for global neighborhood list was set in the reconstruction parameters.
        """

class TriMesh3d:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either `np.float32` or `np.float64`)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    @property
    def triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        The `Mx3` array of vertex indices per triangle
        """
    def vertex_normals_parallel(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Computes the vertex normals of the mesh using an area weighted average of the adjacent triangle faces
        """
    def vertex_vertex_connectivity(self) -> VertexVertexConnectivity:
        r"""
        Computes the vertex-vertex connectivity of the mesh
        """

class TriMesh3dF32:
    r"""
    TriMesh3d wrapper
    """
    def get_vertices(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns a copy of the `Nx3` array of vertex positions
        """
    def get_triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of the `Mx3` array of the vertex indices that make up a triangle
        """
    def get_cells(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Alias for `get_triangles`
        """
    def take_vertices(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Returns the `Nx3` array of vertex positions by moving it out of the mesh (zero copy)
        """
    def take_triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns the `Mx3` array of the vertex indices that make up the triangles by moving it out of the mesh (zero copy)
        """
    def take_cells(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Alias for `take_triangles`
        """
    def take_vertices_and_triangles(self) -> tuple:
        r"""
        Returns a tuple containing the vertices and triangles of the mesh by moving them out of the mesh (zero copy)
        """
    def par_vertex_normals(self) -> numpy.typing.NDArray[numpy.float32]:
        r"""
        Computes the mesh's vertex normals using an area weighted average of the adjacent triangle faces (parallelized version)
        """
    def vertex_vertex_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a mapping of all mesh vertices to the set of their connected neighbor vertices
        """

class TriMesh3dF64:
    r"""
    TriMesh3d wrapper
    """
    def get_vertices(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns a copy of the `Nx3` array of vertex positions
        """
    def get_triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of the `Mx3` array of the vertex indices that make up a triangle
        """
    def get_cells(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Alias for `get_triangles`
        """
    def take_vertices(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Returns the `Nx3` array of vertex positions by moving it out of the mesh (zero copy)
        """
    def take_triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns the `Mx3` array of the vertex indices that make up the triangles by moving it out of the mesh (zero copy)
        """
    def take_cells(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Alias for `take_triangles`
        """
    def take_vertices_and_triangles(self) -> tuple:
        r"""
        Returns a tuple containing the vertices and triangles of the mesh by moving them out of the mesh (zero copy)
        """
    def par_vertex_normals(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        Computes the mesh's vertex normals using an area weighted average of the adjacent triangle faces (parallelized version)
        """
    def vertex_vertex_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a mapping of all mesh vertices to the set of their connected neighbor vertices
        """

class TriMeshWithDataF32:
    r"""
    MeshWithData wrapper
    """
    def __new__(cls, mesh:TriMesh3dF32) -> TriMeshWithDataF32: ...
    def get_mesh(self) -> TriMesh3dF32:
        r"""
        Returns a copy of the contained mesh
        """
    def take_mesh(self) -> TriMesh3dF32:
        r"""
        Returns the contained mesh by moving it out of this object (zero copy)
        """
    def par_clamp_with_aabb(self, aabb:Aabb3dF32, clamp_vertices:builtins.bool, keep_vertices:builtins.bool) -> TriMeshWithDataF32:
        r"""
        Removes all cells from the mesh that are completely outside of the given AABB and clamps the remaining cells to the boundary
        """
    def push_point_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None: ...
    def push_point_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None: ...
    def push_point_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float32]) -> None: ...
    def push_cell_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None: ...
    def push_cell_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None: ...
    def push_cell_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float32]) -> None: ...
    def get_point_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh vertex attribute by name
        """
    def get_cell_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh cell attribute by name
        """
    def get_point_attributes(self) -> dict:
        r"""
        Get all point attributes in a python dictionary
        """
    def get_cell_attributes(self) -> dict:
        r"""
        Get all cell attributes in a python dictionary
        """
    def get_point_attribute_keys(self) -> list:
        r"""
        Get all registered point attribute names
        """
    def get_cell_attribute_keys(self) -> list:
        r"""
        Get all registered cell attribute names
        """

class TriMeshWithDataF64:
    r"""
    MeshWithData wrapper
    """
    def __new__(cls, mesh:TriMesh3dF64) -> TriMeshWithDataF64: ...
    def get_mesh(self) -> TriMesh3dF64:
        r"""
        Returns a copy of the contained mesh
        """
    def take_mesh(self) -> TriMesh3dF64:
        r"""
        Returns the contained mesh by moving it out of this object (zero copy)
        """
    def par_clamp_with_aabb(self, aabb:Aabb3dF64, clamp_vertices:builtins.bool, keep_vertices:builtins.bool) -> TriMeshWithDataF64:
        r"""
        Removes all cells from the mesh that are completely outside of the given AABB and clamps the remaining cells to the boundary
        """
    def push_point_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None: ...
    def push_point_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None: ...
    def push_point_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float64]) -> None: ...
    def push_cell_attribute_scalar_u64(self, name:builtins.str, data:typing.Sequence[builtins.int]) -> None: ...
    def push_cell_attribute_scalar_real(self, name:builtins.str, data:typing.Sequence[builtins.float]) -> None: ...
    def push_cell_attribute_vector_real(self, name:builtins.str, data:numpy.typing.NDArray[numpy.float64]) -> None: ...
    def get_point_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh vertex attribute by name
        """
    def get_cell_attribute(self, name:builtins.str) -> typing.Any:
        r"""
        Get mesh cell attribute by name
        """
    def get_point_attributes(self) -> dict:
        r"""
        Get all point attributes in a python dictionary
        """
    def get_cell_attributes(self) -> dict:
        r"""
        Get all cell attributes in a python dictionary
        """
    def get_point_attribute_keys(self) -> list:
        r"""
        Get all registered point attribute names
        """
    def get_cell_attribute_keys(self) -> list:
        r"""
        Get all registered cell attribute names
        """

class UniformGrid:
    r"""
    Struct containing the parameters of the uniform grid used for the surface reconstruction
    """
    ...

class VertexVertexConnectivity:
    r"""
    Vertex-vertex connectivity of a mesh
    """
    def copy_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a copy of the contained connectivity data
        """
    def take_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns the contained connectivity data by moving it out of this object (zero copy)
        """

class MeshType(Enum):
    r"""
    Enum specifying the type of mesh contained in a `MeshWithData`
    """
    Tri3d = ...
    r"""
    3D triangle mesh
    """
    MixedTriQuad3d = ...
    r"""
    3D mixed triangle and quad mesh
    """

def barnacle_decimation(mesh:typing.Union[TriMesh3d, MeshWithData], *, keep_vertices:builtins.bool) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs specialized decimation on the given mesh to prevent "barnacles" when applying weighted Laplacian smoothing
    
    The decimation is performed inplace and modifies the given mesh.
    Returns the vertex-vertex connectivity of the decimated mesh which can be used for other
    post-processing steps.
    """

def check_mesh_consistency(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, check_closed:builtins.bool=True, check_manifold:builtins.bool=True, debug:builtins.bool=False) -> typing.Optional[builtins.str]:
    r"""
    Checks the consistency of a reconstructed surface mesh (watertightness, manifoldness), optionally returns a string with details if problems are found
    """

def convert_tris_to_quads(mesh:typing.Union[TriMesh3d, MeshWithData], *, non_squareness_limit:builtins.float=1.75, normal_angle_limit:builtins.float=10.0, max_interior_angle:builtins.float=135.0) -> typing.Union[MixedTriQuadMesh3d, MeshWithData]:
    r"""
    Converts triangles to quads by merging triangles sharing an edge if they fulfill the given criteria
    
    This operation creates a new mesh and does not modify the input mesh.
    Angles are specified in degrees.
    """

def laplacian_smoothing_normals_parallel(normals:numpy.typing.NDArray[typing.Any], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int) -> None:
    r"""
    Laplacian smoothing of a normal field
    
    The smoothing is performed inplace and modifies the given normal array.
    """

def laplacian_smoothing_parallel(mesh:typing.Union[TriMesh3d, MeshWithData], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int, beta:builtins.float=1.0, weights:numpy.typing.NDArray[typing.Any]) -> None:
    r"""
    Laplacian smoothing of mesh vertices with feature weights
    
    The smoothing is performed inplace and modifies the vertices of the given mesh.
    """

def marching_cubes_cleanup(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, max_rel_snap_dist:typing.Optional[builtins.float]=None, max_iter:builtins.int=5, keep_vertices:builtins.bool=False) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs simplification on the given mesh designed for marching cubes reconstructions inspired by the "Compact Contouring"/"Mesh displacement" approach by Doug Moore and Joe Warren
    
    The simplification is performed inplace and modifies the given mesh.
    """

def reconstruct_surface(particles:numpy.typing.NDArray[typing.Any], *, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, multi_threading:builtins.bool=True, global_neighborhood_list:builtins.bool=False, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None) -> SurfaceReconstruction:
    r"""
    Performs a surface reconstruction from the given particles without additional post-processing
    
    Note that all parameters use absolute distance units and are not relative to the particle radius.
    """

def reconstruction_pipeline(particles:numpy.typing.NDArray[typing.Any], *, attributes_to_interpolate:typing.Optional[dict]=None, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, multi_threading:builtins.bool=True, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64, check_mesh_closed:builtins.bool=False, check_mesh_manifold:builtins.bool=False, check_mesh_orientation:builtins.bool=False, check_mesh_debug:builtins.bool=False, mesh_cleanup:builtins.bool=False, mesh_cleanup_snap_dist:typing.Optional[builtins.float]=None, decimate_barnacles:builtins.bool=False, keep_vertices:builtins.bool=False, compute_normals:builtins.bool=False, sph_normals:builtins.bool=False, normals_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_weights:builtins.bool=True, mesh_smoothing_weights_normalization:builtins.float=13.0, generate_quads:builtins.bool=False, quad_max_edge_diag_ratio:builtins.float=1.75, quad_max_normal_angle:builtins.float=10.0, quad_max_interior_angle:builtins.float=135.0, output_mesh_smoothing_weights:builtins.bool=False, output_raw_normals:builtins.bool=False, output_raw_mesh:builtins.bool=False, mesh_aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_clamp_vertices:builtins.bool=True, dtype:typing.Optional[numpy.dtype]=None) -> MeshWithData:
    r"""
    Runs the surface reconstruction pipeline for the given particle positions with optional post-processing
    
    Note that smoothing length and cube size are given in multiples of the particle radius.
    """

