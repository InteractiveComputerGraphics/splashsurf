# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

from __future__ import annotations

import builtins
import numpy
import numpy.typing
import os
import pathlib
import typing
from enum import Enum

class Aabb3d:
    r"""
    Three-dimensional axis-aligned bounding box defined by its minimum and maximum corners
    """
    @property
    def min(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        The min coordinate of the AABB
        """
    @property
    def max(self) -> numpy.typing.NDArray[numpy.float64]:
        r"""
        The max coordinate of the AABB
        """
    @staticmethod
    def from_min_max(min:typing.Sequence[builtins.float], max:typing.Sequence[builtins.float]) -> Aabb3d:
        r"""
        Constructs an AABB with the given min and max coordinates
        """
    @staticmethod
    def from_points(points:numpy.typing.NDArray[typing.Any]) -> Aabb3d:
        r"""
        Constructs the smallest AABB fitting around all the given points
        """
    def contains_point(self, point:typing.Sequence[builtins.float]) -> builtins.bool:
        r"""
        Checks if the given point is inside the AABB, the AABB is considered to be half-open to its max coordinate
        """

class MeshAttribute:
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the data stored in the attribute
        """
    @property
    def name(self) -> builtins.str:
        r"""
        Name of the attribute
        """
    @property
    def data(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        View of the attribute data as a numpy array
        """

class MeshWithData:
    r"""
    Mesh with attached point and cell attributes
    """
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either ``np.float32`` or ``np.float64``)
        """
    @property
    def nvertices(self) -> builtins.int:
        r"""
        Number of vertices in the mesh
        """
    @property
    def ncells(self) -> builtins.int:
        r"""
        Number of cells (triangles or quads) in the mesh
        """
    @property
    def mesh_type(self) -> MeshType:
        r"""
        Type of the underlying mesh
        """
    @property
    def mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        The wrapped mesh without associated data and attributes
        """
    @property
    def point_attributes(self) -> dict[str, numpy.typing.NDArray]:
        r"""
        The attributes attached points (vertices) of the mesh
        """
    @property
    def cell_attributes(self) -> dict[str, numpy.typing.NDArray]:
        r"""
        The attributes attached to the cells (triangles or quads) of the mesh
        """
    def __new__(cls, mesh:typing.Union[TriMesh3d, MeshWithData]) -> MeshWithData:
        r"""
        Wraps an existing mesh object (either `TriMesh3d` or `MixedTriQuadMesh3d`) such that data (point and cell attributes) can be attached to it
        """
    def copy_mesh(self) -> typing.Union[TriMesh3d, MixedTriQuadMesh3d]:
        r"""
        Returns a copy of the wrapped mesh without associated data and attributes
        """
    def copy(self) -> MeshWithData:
        r"""
        Returns a copy (deep copy) of this mesh with its data and attributes
        """
    def add_point_attribute(self, name:builtins.str, attribute:numpy.typing.NDArray[typing.Any]) -> None:
        r"""
        Attaches a point attribute to the mesh
        
        There has to be exactly one attribute value per vertex in the mesh.
        As attribute data, the following numpy array types are supported:
         - 1D array with shape (N,) of ``np.uint64``
         - 1D array with shape (N,) of the mesh scalar type (``np.float32`` or ``np.float64``)
         - 2D array with shape (N,3) of the mesh scalar type (``np.float32`` or ``np.float64``)
        The data is copied into the mesh object.
        """
    def add_cell_attribute(self, name:builtins.str, attribute:numpy.typing.NDArray[typing.Any]) -> None:
        r"""
        Attaches a cell attribute to the mesh
        
        There has to be exactly one attribute value per cell in the mesh.
        As attribute data, the following numpy array types are supported:
         - 1D array with shape (N,) of ``np.uint64``
         - 1D array with shape (N,) of the mesh scalar type (``np.float32`` or ``np.float64``)
         - 2D array with shape (N,3) of the mesh scalar type (``np.float32`` or ``np.float64``)
        The data is copied into the mesh object.
        """
    def write_to_file(self, path:builtins.str | os.PathLike | pathlib.Path, *, file_format:typing.Optional[builtins.str]='vtk42') -> None:
        r"""
        Writes the mesh and its attributes to a file using ``meshio.write_points_cells``
        """

class MixedTriQuadMesh3d:
    r"""
    Mixed triangle and quad surface mesh in 3D
    """
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either ``np.float32`` or ``np.float64``)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    def copy(self) -> MixedTriQuadMesh3d:
        r"""
        Returns a copy (deep copy) of this mesh
        """
    def get_triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all triangle cells of the mesh as an `Nx3` array of vertex indices
        """
    def get_quads(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        Returns a copy of all quad cells of the mesh as an `Nx4` array of vertex indices
        """
    def write_to_file(self, path:builtins.str | os.PathLike | pathlib.Path, *, file_format:typing.Optional[builtins.str]='vtk42') -> None:
        r"""
        Writes the mesh to a file using ``meshio.write_points_cells``
        """

class NeighborhoodLists:
    r"""
    Per particle neighborhood lists
    """
    def __len__(self) -> builtins.int:
        r"""
        Returns the number of particles for which neighborhood lists are stored
        """
    def __getitem__(self, idx:builtins.int) -> builtins.list[builtins.int]:
        r"""
        Returns the neighborhood list for the particle at the given index
        """
    def get_neighborhood_lists(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns all stored neighborhood lists as a list of lists
        """

class SphInterpolator:
    r"""
    Interpolator of per-particle quantities to arbitrary points using SPH interpolation (with cubic kernel)
    """
    def __new__(cls, particle_positions:numpy.typing.NDArray[typing.Any], particle_densities:numpy.typing.NDArray[typing.Any], particle_rest_mass:builtins.float, compact_support_radius:builtins.float) -> SphInterpolator:
        r"""
        Constructs an SPH interpolator (with cubic kernels) for the given particles
        """
    def interpolate_quantity(self, particle_quantity:numpy.typing.NDArray[typing.Any], interpolation_points:numpy.typing.NDArray[typing.Any], *, first_order_correction:builtins.bool=False) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Interpolates a scalar or vectorial per particle quantity to the given points
        """
    def interpolate_normals(self, interpolation_points:numpy.typing.NDArray[typing.Any]) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Interpolates surface normals (i.e. normalized SPH gradient of the indicator function) of the fluid to the given points using SPH interpolation
        """

class SurfaceReconstruction:
    r"""
    Result returned by surface reconstruction functions with surface mesh and other data
    """
    @property
    def grid(self) -> UniformGrid:
        r"""
        The marching cubes grid parameters used for the surface reconstruction
        """
    @property
    def particle_densities(self) -> typing.Optional[numpy.typing.NDArray[typing.Any]]:
        r"""
        The global array of particle densities (`None` if they were only computed locally)
        """
    @property
    def particle_inside_aabb(self) -> typing.Optional[numpy.typing.NDArray[typing.Any]]:
        r"""
        A boolean array indicating whether each particle was inside the AABB used for the reconstruction (`None` if no AABB was set)
        """
    @property
    def particle_neighbors(self) -> typing.Optional[NeighborhoodLists]:
        r"""
        The global neighborhood lists per particle (`None` if they were only computed locally)
        """
    @property
    def mesh(self) -> TriMesh3d:
        r"""
        The reconstructed triangle mesh
        """

class TriMesh3d:
    r"""
    Triangle surface mesh in 3D
    """
    @property
    def dtype(self) -> numpy.dtype:
        r"""
        Numpy dtype of the underlying scalar type (either ``np.float32`` or ``np.float64``)
        """
    @property
    def vertices(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        The `Nx3` array of vertex positions of the mesh
        """
    @property
    def triangles(self) -> numpy.typing.NDArray[numpy.uint64]:
        r"""
        The `Mx3` array of vertex indices per triangle
        """
    def copy(self) -> TriMesh3d:
        r"""
        Returns a copy (deep copy) of this mesh
        """
    def vertex_normals_parallel(self) -> numpy.typing.NDArray[typing.Any]:
        r"""
        Computes the vertex normals of the mesh using an area weighted average of the adjacent triangle faces
        """
    def vertex_vertex_connectivity(self) -> VertexVertexConnectivity:
        r"""
        Computes the vertex-vertex connectivity of the mesh
        """
    def write_to_file(self, path:builtins.str | os.PathLike | pathlib.Path, *, file_format:typing.Optional[builtins.str]='vtk42') -> None:
        r"""
        Writes the mesh to a file using ``meshio.write_points_cells``
        """

class UniformGrid:
    r"""
    Struct containing the parameters of the uniform grid used for the surface reconstruction
    """
    @property
    def aabb(self) -> Aabb3d:
        r"""
        The AABB of the grid containing all marching cubes vertices influenced by the particle kernels
        """
    @property
    def cell_size(self) -> builtins.float:
        r"""
        Returns the cell size of the uniform grid (the marching cubes voxel size)
        """
    @property
    def npoints_per_dim(self) -> builtins.list[builtins.int]:
        r"""
        Returns the number of points (marching cubes vertices) per dimension in the uniform grid
        """
    @property
    def ncells_per_dim(self) -> builtins.list[builtins.int]:
        r"""
        Returns the number of cells (marching cubes voxels) per dimension in the uniform grid
        """

class VertexVertexConnectivity:
    r"""
    Vertex-vertex connectivity of a mesh
    """
    def copy_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns a copy of the wrapped connectivity data
        """
    def take_connectivity(self) -> builtins.list[builtins.list[builtins.int]]:
        r"""
        Returns the wrapped connectivity data by moving it out of this object (zero copy)
        """

class MeshType(Enum):
    r"""
    Enum specifying the type of mesh wrapped by a ``MeshWithData``
    """
    Tri3d = ...
    r"""
    3D triangle mesh
    """
    MixedTriQuad3d = ...
    r"""
    3D mixed triangle and quad mesh
    """

def barnacle_decimation(mesh:typing.Union[TriMesh3d, MeshWithData], *, keep_vertices:builtins.bool) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs specialized decimation on the given mesh to prevent "barnacles" when applying weighted Laplacian smoothing
    
    The decimation is performed inplace and modifies the given mesh.
    Returns the vertex-vertex connectivity of the decimated mesh which can be used for other
    post-processing steps.
    """

def check_mesh_consistency(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, check_closed:builtins.bool=True, check_manifold:builtins.bool=True, debug:builtins.bool=False) -> typing.Optional[builtins.str]:
    r"""
    Checks the consistency of a reconstructed surface mesh (watertightness, manifoldness), optionally returns a string with details if problems are found
    """

def convert_tris_to_quads(mesh:typing.Union[TriMesh3d, MeshWithData], *, non_squareness_limit:builtins.float=1.75, normal_angle_limit:builtins.float=10.0, max_interior_angle:builtins.float=135.0) -> typing.Union[MixedTriQuadMesh3d, MeshWithData]:
    r"""
    Converts triangles to quads by merging triangles sharing an edge if they fulfill the given criteria
    
    This operation creates a new mesh and does not modify the input mesh.
    Angles are specified in degrees.
    """

def laplacian_smoothing_normals_parallel(normals:numpy.typing.NDArray[typing.Any], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int) -> None:
    r"""
    Laplacian smoothing of a normal field
    
    The smoothing is performed inplace and modifies the given normal array.
    """

def laplacian_smoothing_parallel(mesh:typing.Union[TriMesh3d, MeshWithData], vertex_connectivity:VertexVertexConnectivity, *, iterations:builtins.int, beta:builtins.float=1.0, weights:numpy.typing.NDArray[typing.Any]) -> None:
    r"""
    Laplacian smoothing of mesh vertices with feature weights
    
    The smoothing is performed inplace and modifies the vertices of the given mesh.
    """

def marching_cubes(values:numpy.typing.NDArray[typing.Any], *, iso_surface_threshold:builtins.float, cube_size:builtins.float, translation:typing.Optional[typing.Sequence[builtins.float]]=None, return_grid:builtins.bool=False) -> typing.Union[TriMesh3d, tuple[TriMesh3d, UniformGrid]]:
    r"""
    Performs a standard marching cubes triangulation of a 3D array of values
    
    The array of values has to be a contiguous array with shape ``(nx, ny, nz)``.
    The iso-surface threshold defines which value is considered to be "on" the surface.
    The cube size and translation parameters define the scaling and translation of the resulting
    mesh. Without translation, the value ``values[0, 0, 0]`` is located at coordinates ``(0, 0, 0)``.
    
    The values are interpreted as a "density field", meaning that values higher than the iso-surface
    threshold are considered to be "inside" the surface and values lower than the threshold are
    considered to be "outside" the surface. This is the opposite convention to an SDF (signed distance field).
    However, even if values of an SDF are provided as an input, the marching cubes algorithm
    will still work and produce a watertight surface mesh (if the surface is fully contained in the
    array).
    
    If ``return_grid`` is set to ``True``, the function will return a tuple of the mesh and the
    uniform grid that was used for the triangulation. This can be used for other functions such as
    :py:func:`check_mesh_consistency`. Otherwise, only the mesh is returned.
    
    The function is currently single-threaded. The SPH surface reconstruction functions :py:func:`reconstruction_pipeline`
    and :py:func:`reconstruct_surface` improve performance by processing multiple patches in parallel.
    """

def marching_cubes_cleanup(mesh:typing.Union[TriMesh3d, MeshWithData], grid:UniformGrid, *, max_rel_snap_dist:typing.Optional[builtins.float]=None, max_iter:builtins.int=5, keep_vertices:builtins.bool=False) -> typing.Union[TriMesh3d, MeshWithData]:
    r"""
    Performs simplification on the given mesh inspired by the "Compact Contouring"/"Mesh displacement" approach by Doug Moore and Joe Warren
    
    The simplification is performed inplace and modifies the given mesh.
    The method is designed specifically for meshes generated by Marching Cubes.
    See Moore and Warren: `Mesh Displacement: An Improved Contouring Method for Trivariate Data <https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.49.5214&rep=rep1&type=pdf>`_ (1991)
    or Moore and Warren: "Compact Isocontours from Sampled Data" in "Graphics Gems III" (1992).
    """

def neighborhood_search_spatial_hashing_parallel(particle_positions:numpy.typing.NDArray[typing.Any], domain:Aabb3d, search_radius:builtins.float) -> NeighborhoodLists:
    r"""
    Performs a neighborhood search using spatial hashing (multithreaded implementation)
    """

def reconstruct_surface(particles:numpy.typing.NDArray[typing.Any], *, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, multi_threading:builtins.bool=True, global_neighborhood_list:builtins.bool=False, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None) -> SurfaceReconstruction:
    r"""
    Performs a surface reconstruction from the given particles without additional post-processing
    
    Note that all parameters use absolute distance units and are not relative to the particle radius.
    """

def reconstruction_pipeline(particles:numpy.typing.NDArray[typing.Any], *, attributes_to_interpolate:typing.Optional[dict]=None, particle_radius:builtins.float, rest_density:builtins.float=1000.0, smoothing_length:builtins.float, cube_size:builtins.float, iso_surface_threshold:builtins.float=0.6, aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, multi_threading:builtins.bool=True, subdomain_grid:builtins.bool=True, subdomain_grid_auto_disable:builtins.bool=True, subdomain_num_cubes_per_dim:builtins.int=64, check_mesh_closed:builtins.bool=False, check_mesh_manifold:builtins.bool=False, check_mesh_orientation:builtins.bool=False, check_mesh_debug:builtins.bool=False, mesh_cleanup:builtins.bool=False, mesh_cleanup_snap_dist:typing.Optional[builtins.float]=None, decimate_barnacles:builtins.bool=False, keep_vertices:builtins.bool=False, compute_normals:builtins.bool=False, sph_normals:builtins.bool=False, normals_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_iters:typing.Optional[builtins.int]=None, mesh_smoothing_weights:builtins.bool=True, mesh_smoothing_weights_normalization:builtins.float=13.0, generate_quads:builtins.bool=False, quad_max_edge_diag_ratio:builtins.float=1.75, quad_max_normal_angle:builtins.float=10.0, quad_max_interior_angle:builtins.float=135.0, output_mesh_smoothing_weights:builtins.bool=False, output_raw_normals:builtins.bool=False, output_raw_mesh:builtins.bool=False, mesh_aabb_min:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_max:typing.Optional[typing.Sequence[builtins.float]]=None, mesh_aabb_clamp_vertices:builtins.bool=True) -> tuple[MeshWithData, SurfaceReconstruction]:
    r"""
    Runs the surface reconstruction pipeline for the given particle positions with optional post-processing
    
    Note that smoothing length and cube size are given in multiples of the particle radius.
    
    Parameters
    ----------
    particles : numpy.ndarray
       A two-dimensional numpy array of shape (N, 3) containing the positions of the particles.
    attributes_to_interpolate
       Dictionary containing all attributes to interpolate. The keys are the attribute names and the values are the corresponding 1D/2D arrays.\n
       The arrays must have the same length as the number of particles. \n
       Supported array types are 2D float32/float64 arrays for vector attributes and 1D uint64/float32/float64 arrays for scalar attributes.
    particle_radius
        Particle radius
    rest_density
        Rest density of the fluid
    smoothing_length
        Smoothing length of the fluid in multiples of the particle radius (compact support radius of SPH kernel will be twice the smoothing length)
    cube_size
        Size of the cubes used for the marching cubes grid in multiples of the particle radius
    iso_surface_threshold
        Threshold for the iso surface
    aabb_min
        Lower corner of the AABB of particles to consider in the reconstruction
    aabb_max
        Upper corner of the AABB of particles to consider in the reconstruction
    multi_threading
        Multi-threading
    subdomain_grid
        Enable spatial decomposition using by dividing the domain into subdomains with dense marching cube grids for efficient multi-threading
    subdomain_grid_auto_disable
        Whether to automatically disable the subdomain grid if the global domain is too small
    subdomain_num_cubes_per_dim
        Each subdomain will be a cube consisting of this number of MC cube cells along each coordinate axis
    check_mesh_closed
        Enable checking the final mesh for holes
    check_mesh_manifold
        Enable checking the final mesh for non-manifold edges and vertices
    check_mesh_orientation
        Enable checking the final mesh for inverted triangles (compares angle between vertex normals and adjacent face normals)
    check_mesh_debug
        Enable additional debug output for the check-mesh operations (has no effect if no other check-mesh option is enabled)
    mesh_cleanup
        Flag to perform mesh cleanup\n
        This implements the method from “Compact isocontours from sampled data” (Moore, Warren; 1992)
    mesh_cleanup_snap_dist
        If MC mesh cleanup is enabled, vertex snapping can be limited to this distance relative to the MC edge length (should be in range of [0.0,0.5])
    decimate_barnacles
        Flag to perform barnacle decimation\n
        For details see “Weighted Laplacian Smoothing for Surface Reconstruction of Particle-based Fluids” (Löschner, Böttcher, Jeske, Bender; 2023).
    keep_vertices
        Flag to keep any vertices without connectivity resulting from mesh cleanup or decimation step
    compute_normals
        Flag to compute normals\n
        If set to True, the normals will be computed and stored in the mesh.
    sph_normals
        Flag to compute normals using SPH interpolation instead of geometry-based normals.
    normals_smoothing_iters
        Number of Laplacian smoothing iterations for the normal field
    mesh_smoothing_iters
        Number of Laplacian smoothing iterations for the mesh
    mesh_smoothing_weights
        Flag to compute mesh smoothing weights\n
        This implements the method from “Weighted Laplacian Smoothing for Surface Reconstruction of Particle-based Fluids” (Löschner, Böttcher, Jeske, Bender; 2023).
    mesh_smoothing_weights_normalization
        Normalization value for the mesh smoothing weights
    generate_quads
        Enable trying to convert triangles to quads if they meet quality criteria
    quad_max_edge_diag_ratio
        Maximum allowed ratio of quad edge lengths to its diagonals to merge two triangles to a quad (inverse is used for minimum)
    quad_max_normal_angle
        Maximum allowed angle (in degrees) between triangle normals to merge them to a quad
    quad_max_interior_angle
        Maximum allowed vertex interior angle (in degrees) inside a quad to merge two triangles to a quad
    output_mesh_smoothing_weights
        Flag to store the mesh smoothing weights if smoothing weights are computed.
    output_raw_normals
        Flag to output the raw normals in addition to smoothed normals if smoothing of normals is enabled
    output_raw_mesh
        When true, also return the SurfaceReconstruction object with no post-processing applied
    mesh_aabb_min
        Smallest corner of the axis-aligned bounding box for the mesh
    mesh_aabb_max
        Largest corner of the axis-aligned bounding box for the mesh
    mesh_aabb_clamp_vertices
        Flag to clamp the vertices of the mesh to the AABB
    """
